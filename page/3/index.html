<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://xu6148152.github.io/page/3/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale">
<meta property="article:author" content="Binea">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xu6148152.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-深入理解Python之并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2017-08-12T16:53:36.000Z" itemprop="datePublished">2017-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%B9%B6%E5%8F%91/">深入理解Python之并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文主要关注<code>Python</code>中的并发库<code>concurrent.feature</code>，其在<code>Python3.2</code>引入</p>
<h3 id="案例-用三种方式进行Web下载"><a href="#案例-用三种方式进行Web下载" class="headerlink" title="案例:用三种方式进行Web下载"></a>案例:用三种方式进行Web下载</h3><p>为了高效的处理网络<code>I/O</code>，我们需要并发。以下三个例子用于展示三个方式下载图片</p>
<ol>
<li><p>串行下载</p>
<p>&lt;!–code￼0–&gt;
</p>
</li>
<li><p>线程池下载</p>
</li>
</ol>
<p>&lt;!–code￼1–&gt;
</p>
<h4 id="Future在哪里？"><a href="#Future在哪里？" class="headerlink" title="Future在哪里？"></a>Future在哪里？</h4><p><code>Future</code>是<code>concurrent.futures</code>和<code>asyncio</code>重要的组件，但作为这些库的使用者，我们通常看不到它</p>
<p><code>Python3.4</code>标准库有两个叫<code>Future</code>的库<code>concurrent.futures.Future</code>和<code>asyncio.Future</code>。他们有相同的目的，表示一个延时的计算，其很像<code>JavaScript</code>中的<code>Promise</code>。</p>
<p><code>Futures</code>封装了等待操作，以便能够放入队列，查询状态，以及能够收到完成的结果。</p>
<p>通常，我们不应该创建<code>Futures</code>，它们由并发框架创建并管理，。这很重要</p>
<p>客户端不应该改变<code>Future</code>的状态，这是由框架完成的。</p>
<p>两种类型的<code>Future</code>都有一个非阻塞<code>done</code>方法，返回<code>Boolean</code>值，告知调用者，回调是否和<code>future</code>连接。客户端通常会使用<code>add_done_callback()</code>要求<code>future</code>通知结果。</p>
<p><code>result()</code>方法，返回回调结果，或者抛出异常。然而如果<code>future</code>没有完成，两种<code>Future</code>的行为有巨大的差异。<code>concurrency.futures.Future</code>实例，当触发<code>result</code>时会阻塞调用线程，直到结果完成，可以设置超时时间。而<code>asyncio.Future</code>不支持超时时间，一般其会使用<code>yield from</code>来获取<code>future</code>的结果</p>
<ol start="3">
<li>异步下载<p>&lt;!–code￼2–&gt;</p>
</li>
</ol>
<p>严格上来讲，上述并发程序并不能并行下载，<code>concurrent.futures</code>被<code>GIL</code>(全局解释器锁)限制</p>
<h3 id="阻塞I-x2F-O和GIL-全局解释器锁"><a href="#阻塞I-x2F-O和GIL-全局解释器锁" class="headerlink" title="阻塞I&#x2F;O和GIL(全局解释器锁)"></a>阻塞I&#x2F;O和GIL(全局解释器锁)</h3><p><code>CPython</code>解释器内部不是线程安全的，因此其有个全局解释器锁，同一时刻只允许一个线程运行。</p>
<p>通常，我们写<code>Python</code>时无法越过<code>GIL</code>，但内置方法或者使用<code>C</code>语言能够释放<code>GIL</code>。事实上，<code>C</code>写的<code>Python</code>库能够管理<code>GIL</code>，放出操作系统线程，充分利用<code>CPU</code>的核心，但这让<code>CODE</code>的复杂度大大增加，因此大多数的库都不会这么做</p>
<p>然而，所有的标准库方法，只要执行阻塞<code>I/O</code>操作，就会释放<code>GIL</code>。这意味着，当一个线程正在等待结果，阻塞<code>I/O</code>的函数释放了<code>GIL</code>，另一个线程可以运行</p>
<h3 id="使用concurrent-futures发起进程"><a href="#使用concurrent-futures发起进程" class="headerlink" title="使用concurrent.futures发起进程"></a>使用concurrent.futures发起进程</h3><p>使用<code>ProcessPoolExecutor</code>可以绕过<code>GIL</code>使用所有<code>CPU</code></p>
<p>&lt;!–code￼3–&gt;
</p>
<p><code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>的区别在于前者初始化的时候需要指定线程数量，而后者是可选</p>
<h3 id="使用Executor-map"><a href="#使用Executor-map" class="headerlink" title="使用Executor.map"></a>使用Executor.map</h3><p>&lt;!–code￼4–&gt;
</p>
<p><code>Executor.map</code>用起来很简单，但它有个功能看起来可能不是很有用，它返回结果的顺序和调用的顺序一致，如果不想要这样，可以使用<code>executor.submit()</code>和<code>as_completed()</code>函数</p>
<h3 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h3><p>下面分别有使用线程和协程的例子</p>
<p>线程:</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>协程</p>
<p>&lt;!–code￼6–&gt;
</p>
<p>两者的主要区别:</p>
<ul>
<li><code>asyncio.Task</code>功能与<code>threading</code>完全相同</li>
<li><code>Task</code>驱动协程，而<code>Thread</code>触发回调</li>
<li>不需要自己初始化<code>Task</code>对象，通过传入一个协程到<code>asyncio.async()</code>或者<code>loop.create_task()</code>中获取</li>
<li>拿到一个<code>Task</code>对象时，其他它已经准备要运行了，而线程必须显式的调用<code>start</code></li>
<li>线程中，目标方法由线程调用，而协程中由<code>yield from</code>驱动的协程调用</li>
<li>没有接口能够从外部中断线程。<code>Task</code>可以调用<code>cancel</code>，其会在协程内抛出<code>CancelledError</code></li>
<li><code>supervisor</code>协程必须在主函数中使用<code>loop.run_until_complete</code>执行</li>
<li><code>Thread</code>可能需要锁来控制状态，而协程状态由内部控制</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%B9%B6%E5%8F%91/" data-id="cl45dkwg7003969kc0m6lhncw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python-%E5%B9%B6%E5%8F%91/" rel="tag">Python, 并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之协程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time datetime="2017-07-22T08:19:40.000Z" itemprop="datePublished">2017-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%8D%8F%E7%A8%8B/">深入理解Python之协程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Python</code>中在生成器中使用<code>yield</code>，其产生数据，被<code>next()</code>的调用者接收。其也会挂起生成器的执行以便调用者已经准备好接收下一个值，调用者从生成器拉数据</p>
<p>协程<code>coroutine</code>语法就像生成器。但是协程的<code>yield</code>通常会出现在表达式右侧。如果不产生值，那么<code>yield</code>之后跟着<code>None</code>。协程可能会从调用者接收数据，调用者会使用<code>.send(datum)</code>来传数据给协程，通常，调用者会将数据压入协程</p>
<p>有可能没有数据经过<code>yield</code>。除了控制数据流之外，<code>yield</code>能够控制调度器使多任务协作。</p>
<p>本文将讲述</p>
<ul>
<li>生成器作为协程时的表现和状态</li>
<li>使用装饰器自动准备协程</li>
<li>调用者如何通过<code>.close</code>和<code>.throw</code>来控制协程</li>
<li>协程如何根据终端返回值</li>
<li><code>yield</code>的新语法使用</li>
<li>模拟协程管理并发</li>
</ul>
<h3 id="协程如何从生成器进化"><a href="#协程如何从生成器进化" class="headerlink" title="协程如何从生成器进化"></a>协程如何从生成器进化</h3><p>协程的基础框架出现在<code>Python2.5</code>，从那时起，<code>yield</code>能够在表达式中使用。调用者能够使用<code>.send()</code>来发数据，该数据变成<code>yield</code>的值.这样子生成器变成协程了。</p>
<p><code>Python3.3</code>中，协程有两个语法改变</p>
<ul>
<li>生成器能够返回值。在这之前会抛出<code>SyntaxError</code></li>
<li><code>yield from</code></li>
</ul>
<h4 id="协程的基本行为"><a href="#协程的基本行为" class="headerlink" title="协程的基本行为"></a>协程的基本行为</h4><p>&lt;!–code￼0–&gt;
</p>
<p>协程有四个状态。可以使用<code>inspect.getgeneratorstate()</code>来确定当前的状态</p>
<ul>
<li><code>GEN_CREATED</code>:等待开始执行</li>
<li><code>GEN_RUNNING</code>: 当前被解释器执行</li>
<li><code>GEN_SUSPENDED</code>: 当前被<code>yield</code>表达式挂起</li>
<li><code>GEN_CLOSED</code>: 执行已经完成</li>
</ul>
<p>&lt;!–code￼1–&gt;
</p>
<p>如果创建一个协程并立即发送一个非<code>None</code>的值，那么会抛出异常</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>这个方法调用时，分三步，最初初始化方法，创建协程，之后每执行一次<code>next</code>，执行到第一个<code>yield</code>表达式</p>
<h3 id="协程示例"><a href="#协程示例" class="headerlink" title="协程示例"></a>协程示例</h3><p>&lt;!–code￼3–&gt;
</p>
<p>创建协程，启动<code>next(coro_avg)</code>协程，调用<code>send</code>修改<code>yield</code>右值，每次执行到<code>yield</code>时，会挂起协程，等待下次数据的到来</p>
<h3 id="协程初始化装饰器"><a href="#协程初始化装饰器" class="headerlink" title="协程初始化装饰器"></a>协程初始化装饰器</h3><p>如果没有包装，那么我们每次使用协程都必须调用<code>next(my_coro)</code>。为了使协程用起来更方便.有时会使用装饰器</p>
<p>&lt;!–code￼4–&gt;
</p>
<h3 id="中断协程和异常处理"><a href="#中断协程和异常处理" class="headerlink" title="中断协程和异常处理"></a>中断协程和异常处理</h3><p>协程内未处理的异常会传播给引起它的<code>next</code>或者<code>send</code>的调用者</p>
<p>中断协程的方法之一，发送一些标记告知协程退出。从<code>Python2.5</code>开始，生成器对象有两个方法允许客户端显式发送异常给协程–<code>throw</code>和<code>close</code></p>
<p><code>throw</code>: 使<code>yield</code>抛出异常，如果异常被生成器处理了，流程会进入下一个<code>next</code>。如果异常没被处理，传播给调用者</p>
<p><code>close</code>: 抛出<code>Generator Exit exception</code>，如果生成器没有处理异常，不会报告任何错误给调用者.当收到<code>GeneratorExit</code>，生成器不能<code>yield value</code>，否则会抛出<code>timeError</code>异常，如果生成器抛出其他异常，会反馈给调用者</p>
<p>&lt;!–code￼5–&gt;
</p>
<h3 id="协程中返回值"><a href="#协程中返回值" class="headerlink" title="协程中返回值"></a>协程中返回值</h3><p>&lt;!–code￼6–&gt;
</p>
<h3 id="使用yield-from"><a href="#使用yield-from" class="headerlink" title="使用yield from"></a>使用yield from</h3><p>&lt;!–code￼7–&gt;
</p>
<p>上面两个方法的结果一样。<code>yield from</code>类似其他语言的<code>await</code></p>
<p>&lt;!–code￼8–&gt;
</p>
<h3 id="案例-协程模拟离散事件"><a href="#案例-协程模拟离散事件" class="headerlink" title="案例:协程模拟离散事件"></a>案例:协程模拟离散事件</h3><p>&lt;!–code￼9–&gt;
</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%8D%8F%E7%A8%8B/" data-id="cl45dkwg6003569kc12k824ud" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之Context-Manager" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BContext-Manager/" class="article-date">
  <time datetime="2017-07-15T07:49:07.000Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BContext-Manager/">深入理解Python之Context Manager</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title=" 概述"></a> 概述</h3><p>本文主要讨论<code>Python</code>中的控制流特性</p>
<ul>
<li><code>with</code>和<code>context manager</code></li>
<li><code>else</code>在<code>for,while,try</code>中的使用</li>
</ul>
<p><code>with</code>表达式创建临时可靠的上下文。这能防止错误和减少模板代码，使<code>API</code>更便于使用和更安全。经常能够发现使用<code>with</code>表达式能够实现文件的自动关闭。</p>
<h3 id="先做这个，然后做那个-if之后是else块"><a href="#先做这个，然后做那个-if之后是else块" class="headerlink" title="先做这个，然后做那个:if之后是else块"></a>先做这个，然后做那个:if之后是else块</h3><ul>
<li><code>for</code>: 循环执行完并且没有执行<code>if</code><p>&lt;!–code￼0–&gt;</p>
</li>
<li>while: 当循环条件变成<code>false</code>，循环退出执行</li>
<li>try: 当<code>try</code>块中没有抛出异常执行<p>&lt;!–code￼1–&gt;</p>
</li>
</ul>
<h3 id="Context-Manager和with"><a href="#Context-Manager和with" class="headerlink" title="Context Manager和with"></a>Context Manager和with</h3><p>上下文管理器对象用于管理<code>with</code>表达式，就像迭代器用于管理<code>for</code>表达式</p>
<p><code>with</code>表达式被设计用来简化<code>try/finally</code>模式，保证某些操作最后一定能够执行。</p>
<p>上下文管理器协议包含<code>__enter__</code>和<code>__exit__</code>方法.<code>with</code>开始,<code>__enter__</code>触发，而<code>__exit__</code>扮演了<code>finally</code>的角色，离开<code>with</code>块执行</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>上述代码打开文件，结束之后会自动关闭文件</p>
<p>&lt;!–code￼3–&gt;
</p>
<h3 id="contextib工具"><a href="#contextib工具" class="headerlink" title="contextib工具"></a>contextib工具</h3><ul>
<li>closing: 创建对象上下文管理器，提供<code>close</code>方法，不需要实现<code>__enter__</code>和<code>__exit__</code></li>
<li>suppress: 上下文管理器临时忽略指定的异常</li>
<li>@contextmanager: 直接生成上下文管理器，而不需要实现<code>__enter__</code>和<code>__exit__</code></li>
<li>ContextDecorator: 上下文管理器装饰器基类</li>
<li>ExitStack: 能够进入几个上下文管理器。当<code>with</code>块结束,其会使用后进先出调用栈中的上下文管理器的<code>__exit__</code></li>
</ul>
<h3 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h3><p><code>@contextmanager</code>减少创建上下文管理器的模板代码。使用<code>@contextmanager</code>时,<code>yield</code>会将函数分成两部分，之前的部分会在<code>__enter__</code>中执行，之后的部分会在<code>__exit__</code>中执行</p>
<p>&lt;!–code￼4–&gt;
</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/07/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BContext-Manager/" data-id="cl45dkwg2002w69kccla7106a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之Iterable-Iterators-and-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BIterable-Iterators-and-Generators/" class="article-date">
  <time datetime="2017-07-08T09:22:37.000Z" itemprop="datePublished">2017-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BIterable-Iterators-and-Generators/">深入理解Python之Iterable,Iterators and Generators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Python</code>使用<code>yield</code>关键字来构造生成器，并以迭代器的方式工作。每个生成器都是一个迭代器，生成器实现迭代器接口。</p>
<p>本文主要内容</p>
<ul>
<li>迭代器的内部实现方式</li>
<li><code>Python</code>中实现传统迭代器模式</li>
<li>生成器的实现方式</li>
<li>传统迭代器如何被生成器替代</li>
<li>利用标准库里的通用生成器</li>
<li>使用<code>yield</code>合并生成器</li>
<li>生成器和协程很像，但实际上差距很大</li>
</ul>
<h3 id="单词序列"><a href="#单词序列" class="headerlink" title="单词序列"></a>单词序列</h3><p>通过实现一个<code>Sentence</code>类来解释迭代</p>
<p>&lt;!–code￼0–&gt;
</p>
<h4 id="为什么Sentence是可迭代的"><a href="#为什么Sentence是可迭代的" class="headerlink" title="为什么Sentence是可迭代的"></a>为什么Sentence是可迭代的</h4><p>当解释器需要迭代一个对象时，其会调用内置方法<code>__iter__</code>,调用顺序</p>
<ol>
<li>检查对象是否实现了<code>__iter__</code>，如果实现了，获取迭代器</li>
<li>如果没有实现<code>__iter__</code>，但是实现了<code>__getitem__</code>,<code>Python</code>会创建一个迭代器，然后会按顺序获取值</li>
<li>如果都没有，那么会抛出异常</li>
</ol>
<p>这就是<code>Sentence</code>能迭代的原因，其实现了<code>__getitem__</code>。事实上，标准库序列都实心了<code>__iter__</code>。对于<code>__getietm__</code>的支持有可能会被去掉。<code>Python3.4</code>检查是否可迭代的最准确的方式是<code>iter(x)</code></p>
<h3 id="可迭代和迭代器"><a href="#可迭代和迭代器" class="headerlink" title="可迭代和迭代器"></a>可迭代和迭代器</h3><ul>
<li>可迭代，对象内置<code>iter</code>能够获取一个迭代器。<code>Python</code>从可迭代对象中获取迭代器。</li>
</ul>
<p>迭代器的标准接口有两个方法</p>
<ol>
<li><code>__next__</code>: 返回下一个值，如果没有更多值了，抛出<code>StopIteration</code>异常</li>
<li><code>__iter__</code>: 返回迭代器自身</li>
</ol>
<p>&lt;!–code￼1–&gt;
</p>
<h3 id="传统迭代器"><a href="#传统迭代器" class="headerlink" title="传统迭代器"></a>传统迭代器</h3><p>&lt;!–code￼2–&gt;
</p>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><p>&lt;!–code￼3–&gt;
</p>
<h3 id="生成器如何工作"><a href="#生成器如何工作" class="headerlink" title="生成器如何工作"></a>生成器如何工作</h3><p>当调用<code>yield</code>时，返回一个生成器对象，换句话说，生成器方法是个生成器工厂</p>
<p>&lt;!–code￼4–&gt;
</p>
<h3 id="更偷懒的实现方式"><a href="#更偷懒的实现方式" class="headerlink" title="更偷懒的实现方式"></a>更偷懒的实现方式</h3><p>&lt;!–code￼5–&gt;
</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>&#96;&#96;&#96;Python</p>
<p>RE_WORD &#x3D; re.compile(‘\w+’)</p>
<p>class Sentence:
    def <strong>init</strong>(self, text):
        self.text &#x3D; text</p>
<pre><code>def __repr__(self):
    return &#39;Sentence(%s)&#39; % reprlib.repr(self.text)

def __iter__(self):
    return (match.group() for match in RE_WORD.finditer(self.text))

</code></pre>
<p>&#96;&#96;&#96;  </p>
<h3 id="迭代器和协程"><a href="#迭代器和协程" class="headerlink" title="迭代器和协程"></a>迭代器和协程</h3><p><code>Python2.5</code>加入了协程</p>
<p>生成器产生数据<br>协程消耗数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/07/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8BIterable-Iterators-and-Generators/" data-id="cl45dkwg3003069kc067q6iu3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之正确的操作符重载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="article-date">
  <time datetime="2017-06-10T08:23:07.000Z" itemprop="datePublished">2017-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/">深入理解Python之正确的操作符重载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>文本将包括以下内容</p>
<ul>
<li><code>Python</code>如何支持不同类型的中缀操作符</li>
<li>使用鸭子类型或者显式类型检查来处理各种类型的操作数</li>
<li>中缀操作符方法如果知道不处理操作数</li>
<li>各种比较操作符的特殊行为</li>
</ul>
<h3 id="操作符101"><a href="#操作符101" class="headerlink" title="操作符101"></a>操作符101</h3><p>操作符重载在某些圈子有不好的名声。它是一种容易被滥用的语言特性，导致别人困惑，<code>bugs</code>和意想不到的性能瓶颈。但是如果用好它，能产生令人愉快的<code>APIs</code>和阅读性很好的代码。<code>Python</code>在灵活，可用，安全之间做了平衡。使用以下的限制:</p>
<ul>
<li>不能重载内置类型操作符</li>
<li>不能创建新的操作符，只能重载原有的</li>
<li>几个操作符不能重载: <code>is, and, or, not</code></li>
</ul>
<p>下面开始讨论最简单的一元操作符</p>
<h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><ul>
<li><code>-(__neg__)</code></li>
<li><code>+(__pos__)</code></li>
<li><code>~(__invert__)</code></li>
</ul>
<p>&lt;!–code￼0–&gt;
</p>
<h4 id="什么时候-x-x"><a href="#什么时候-x-x" class="headerlink" title="什么时候 x != +x?"></a>什么时候 <code>x != +x</code>?</h4><p>正常情况下<code>x==+x</code>。以下情况两者不相等</p>
<p>第一种情况, <code>decimal.Decimal</code>中，如果<code>x</code>在数学上下文中创建，而<code>+x</code>在不一样的上下文中创建。</p>
<p>&lt;!–code￼1–&gt;
</p>
<p><code>Decimal</code>的精度被改变。<code>one_third</code>和<code>+one_third</code>值不相等。原因是<code>+one_third</code>用新精度会产生一个新的<code>Decimal</code></p>
<p>第二种情况是<code>collections.Counter</code>，其实现了几个数学操作符。如果使用<code>+</code>操作符，那么会丢弃<code>0</code>及负数</p>
<p>&lt;!–code￼2–&gt;
</p>
<h3 id="为向量相加重载"><a href="#为向量相加重载" class="headerlink" title="为向量相加重载+"></a>为向量相加重载<code>+</code></h3><p>&lt;!–code￼3–&gt;
</p>
<p><code>pairs</code> 是个生成器，能产生<code>tuple(a, b)</code>,<code>a</code>从<code>self</code>,<code>b</code>从<code>other</code>，如果两者的长度不一致，那么会使用<code>fillvalue</code>填充</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>然而使用上述表达式会出错。</p>
<p>为了支持不同类型的操作符，<code>Python</code>实现了特殊的下发机制.例如<code>a+b</code>会执行以下步骤</p>
<ol>
<li>如果<code>a</code>有<code>__add__</code>，调用<code>a.__add__(b)</code>，然后返回结果</li>
<li>如果<code>a</code>没有<code>__add__</code>，或者调用它返回<code>NotImplemented</code>，检查<code>b</code>是否有<code>__radd__</code>，然后调用<code>b.__radd__(a)</code>，然后返回结果</li>
<li>如果<code>b</code>也不含有<code>__radd__</code>，或者调用它返回<code>NotImplemented</code>。抛出<code>TypeError</code></li>
</ol>
<p>因此为了使上述的表达式能够正确运行，我们需要实现<code>__radd__</code>方法</p>
<p>&lt;!–code￼5–&gt;
</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载*"></a>重载<code>*</code></h3><p>&lt;!–code￼6–&gt;
</p>
<p>判断被乘数是否是实数</p>
<p>&lt;!–code￼7–&gt;
</p>
<h3 id="丰富的比较操作符"><a href="#丰富的比较操作符" class="headerlink" title="丰富的比较操作符"></a>丰富的比较操作符</h3><p>&lt;!–code￼8–&gt;
</p>
<p>&lt;!–code￼9–&gt;
</p>
<h3 id="增量赋值操作符"><a href="#增量赋值操作符" class="headerlink" title="增量赋值操作符"></a>增量赋值操作符</h3><p>&lt;!–code￼10–&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/" data-id="cl45dkwgb003j69kc47td2hph" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Java之NIO概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B9%8BNIO%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2017-06-03T09:16:37.000Z" itemprop="datePublished">2017-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B9%8BNIO%E6%A6%82%E8%BF%B0/">深入理解Java之NIO概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Java</code> NIO是从<code>Java1.4</code>后加入的新型<code>IO API</code>。主要包括了以下的核心组件</p>
<ul>
<li>通道</li>
<li>缓冲</li>
<li>选择器</li>
</ul>
<h4 id="Java-NIO-通道和缓冲"><a href="#Java-NIO-通道和缓冲" class="headerlink" title="Java NIO: 通道和缓冲"></a>Java NIO: 通道和缓冲</h4><p>标准的<code>IO API</code>中，使用字节流和字符流。在<code>NIO</code>中使用通道和缓冲。数据总是从通道读取然后放入缓冲或者从缓冲读取写入通道</p>
<p><img data-src="/./channel.png" alt="channel"></p>
<p>有几种通道和缓冲类型，以下是主要通道类型</p>
<ul>
<li><code>FileChannel</code>(文件通道)</li>
<li><code>DatagramChannel</code>(数据报通道)</li>
<li><code>SocketChannel</code>(套接字通道)</li>
<li><code>ServerSocketChannel</code>(服务器套接字通道)</li>
</ul>
<p>这些通道覆盖了 <code>UDP+TCP</code>的网络<code>IO</code>以及文件<code>IO</code></p>
<p>以下是和兴的缓冲实现</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>DoubleBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>ShortBuffer</code></li>
</ul>
<p>这些缓冲结构覆盖了基本数据类型</p>
<h4 id="Java-NIO-非阻塞IO"><a href="#Java-NIO-非阻塞IO" class="headerlink" title="Java NIO: 非阻塞IO"></a>Java NIO: 非阻塞<code>IO</code></h4><p><code>Java NIO</code>能够做到非阻塞<code>IO</code>。例如，一个线程能够从通道读取数据到缓冲。当通道读取数据到缓冲时，线程可以做其他事情。一旦数据读取完，线程能够继续执行它</p>
<h4 id="Java-NIO-选择器"><a href="#Java-NIO-选择器" class="headerlink" title="Java NIO: 选择器"></a>Java NIO: 选择器</h4><p><code>Java NIO</code>包含了选择器的概念。选择器是一种对象，其能够监视多个通道的事件，因此单线程能够监控多通道的数据</p>
<p>下图是一个线程使用选择器处理三个通道</p>
<p><img data-src="/./selector.png" alt="selector"></p>
<p>为了使用选择器，首先需要将选择器注册到通道，然后调用<code>select()</code>方法。这个方法会阻塞直到这些通道产生了任意一个准备好的事件。一旦方法返回了，线程可以处理这些事件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/06/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B9%8BNIO%E6%A6%82%E8%BF%B0/" data-id="cl45dkwg0002s69kc6ovucuwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-NIO/" rel="tag">Java NIO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E7%BB%A7%E6%89%BF/" class="article-date">
  <time datetime="2017-06-01T08:56:55.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E7%BB%A7%E6%89%BF/">深入理解Python之继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="继承内置类型的技巧"><a href="#继承内置类型的技巧" class="headerlink" title="继承内置类型的技巧"></a>继承内置类型的技巧</h3><p><code>Python2.2</code>之前，不能够继承内置类型</p>
<p>&lt;!–code￼0–&gt;
</p>
<p><code>DoppelDict</code>当排序时，复制值.<code>__init__</code>忽略<code>__setitem__</code>被重写，因此<code>one</code>没有被复制。<code>[]</code>操作符调用<code>__setitem__</code>，因此<code>two</code>被复制。<code>update</code>方法没有使用重写的<code>__setitem__</code>方法。因此<code>three</code>没有复制</p>
<p>方法的寻找总是从目标对象开始，然后向上寻找</p>
<p>&lt;!–code￼1–&gt;
</p>
<p><code>AnswerDict.__getitem__()</code>总是返回42.<code>d</code>是个<code>dict</code>，使用<code>ad</code>更新它，忽略了<code>AnswerDict.__getitem__()</code></p>
<p>直接继承内置类型如<code>dict</code>或者<code>list</code>容易出错，因为内置的方法大多数会忽略用户自定的方法。因此从<code>collections</code>模块中使用<code>UserDict</code>,<code>UserLisat</code>,<code>UserString</code>来派生类</p>
<p>&lt;!–code￼2–&gt;
</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>&lt;!–code￼3–&gt;
</p>
<p>当在一个类上直接调用方法时，需要显式传入<code>self</code>。调用方法的顺序依据<code>MRO(__mro__)</code>采用<code>C3</code>算法</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>其搜索路径就是按着<code>Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object</code>从左往右搜索</p>
<p>对于多重继承来说，继承顺序决定了搜索顺序</p>
<h3 id="真实的多重继承案例"><a href="#真实的多重继承案例" class="headerlink" title="真实的多重继承案例"></a>真实的多重继承案例</h3><p>适配器模式就使用了多重继承.<code>Python</code>中最常见的多重继承是<code>collection.abc</code>包。标准库<code>Tkinter GUI</code>使用了大量的多重继承</p>
<p>&lt;!–code￼5–&gt;
</p>
<h3 id="应对多重继承"><a href="#应对多重继承" class="headerlink" title="应对多重继承"></a>应对多重继承</h3><ol>
<li><p>区分接口继承和实现继承</p>
<ul>
<li>接口继承创建子类型，实现<code>is-a</code>关系</li>
<li>实现继承利于代码复用</li>
</ul>
</li>
<li><p>使用<code>ABCs</code>来创造接口
</p>
</li>
<li><p>使用<code>Mixin</code>来使代码复用</p>
<p>如果一个类被设计成为多个不相关的类提供复用，那么请继承<code>Mixin</code>, <code>Mixin</code>不会定义新类型，只是封装方法以便复用.<code>Mixin</code>不该被实例化，任何实体类都不该仅仅只继承<code>Mixin</code>. 每个<code>Mixin</code>应该只提供一种单一特定的行为，实现几个紧密相关的方法</p>
</li>
<li><p>显式命名<code>Mixin</code></p>
<p>没有标准的方式来说明一个类是<code>Mixin</code>，因此建议使用<code>Mixin</code>作为后缀</p>
</li>
<li><p><code>ABC</code>可能是<code>Mixin</code>，反过来不一定成立</p>
</li>
<li><p>不要继承多个实体类</p>
</li>
<li><p>提供集合类给用户</p>
</li>
<li><p>组合胜过继承</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E7%BB%A7%E6%89%BF/" data-id="cl45dkwgd003l69kc4rcp6cmy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2017-05-30T08:38:58.000Z" itemprop="datePublished">2017-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%8E%A5%E5%8F%A3/">深入理解Python之接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Python文化中的接口和协议"><a href="#Python文化中的接口和协议" class="headerlink" title="Python文化中的接口和协议"></a>Python文化中的接口和协议</h3><p><code>Python</code>在<code>ABCs</code>引入之前已经很成功了.接口在动态语言中是如何工作的。其没有<code>interface</code>关键字。对于<code>ABCs</code>，每个类有个接口。协议是接口。接口的定义是对象公共方法的子集，能够实现特定的功能。<code>Python</code>中最基础的接口之一是序列协议</p>
<h3 id="运行中实现协议"><a href="#运行中实现协议" class="headerlink" title="运行中实现协议"></a>运行中实现协议</h3><p>&lt;!–code￼0–&gt;
</p>
<p>对于普通自定义对象，如果想使用<code>shuffle</code>那么需要实现<code>__setitem__</code>,因此可以动态设置<code>xxx.__setitem__ = set_xxx</code>。但这其中暴露了<code>__setitem__</code>给外界，破坏了封装性</p>
<h3 id="ABC子类"><a href="#ABC子类" class="headerlink" title="ABC子类"></a>ABC子类</h3><p>&lt;!–code￼1–&gt;
</p>
<p>继承链是<code>MutableSequence</code>-&gt;<code>Sequence</code></p>
<h3 id="标准库中的ABCs"><a href="#标准库中的ABCs" class="headerlink" title="标准库中的ABCs"></a>标准库中的ABCs</h3><p><code>Python2.6</code>之后引入了<code>ABCs</code></p>
<h4 id="collections-abc"><a href="#collections-abc" class="headerlink" title="collections.abc"></a>collections.abc</h4><ul>
<li><code>Iterable</code>, <code>Container</code>, <code>Sized</code></li>
<li><code>Sequence</code>, <code>Mapping</code>, <code>Set</code></li>
<li><code>MappingView</code></li>
<li><code>Callable</code>, <code>Hashable</code></li>
<li><code>Iterator</code></li>
</ul>
<p>除了<code>collections.abc</code>之外，标准库中最有用的<code>ABCs</code>就是<code>numbers</code></p>
<h4 id="numbers"><a href="#numbers" class="headerlink" title="numbers"></a>numbers</h4><ul>
<li><code>Number</code></li>
<li><code>Complex</code></li>
<li><code>Real</code></li>
<li><code>Rational</code></li>
<li><code>Integral</code></li>
</ul>
<p>因此我们需要使用<code>isinstance(x, numbers.Integral)</code>来检查整形。需要注意的是<code>decimal.Decimal</code>没有成为<code>numbers.Real</code>的子类</p>
<h3 id="定义和使用ABC"><a href="#定义和使用ABC" class="headerlink" title="定义和使用ABC"></a>定义和使用ABC</h3><p>假设我们需要在网页或者<code>APP</code>上随机展示广告。我们将定义名为<code>Tombola</code>的抽象类。</p>
<p><code>Tombola</code>抽象类有四个方法。两个抽象方法是
* <code>load()</code>: 放条目到容器中
* <code>pick()</code>: 随机移除并返回条目</p>
<p>实体方法</p>
<ul>
<li><code>loaded()</code>: 如果容器至少有一个条目，那么返回<code>True</code></li>
<li><code>inspect()</code>: 返回排过序的的元组</li>
</ul>
<p><img data-src="/./tombola.png" alt="tombola"></p>
<p>&lt;!–code￼2–&gt;
</p>
<p>使用<code>@abc.abstractmethod</code>标识抽象方法</p>
<p>&lt;!–code￼3–&gt;
</p>
<h4 id="ABC详细语法"><a href="#ABC详细语法" class="headerlink" title="ABC详细语法"></a>ABC详细语法</h4><p>声明抽象类的最好方式是继承<code>abc.ABC</code>或者其他<code>ABC</code>。然而<code>abc.ABC</code>是<code>Python3.4</code>才引入的。在这此前必须使用<code>metaclass=keyword</code></p>
<p>&lt;!–code￼4–&gt;
</p>
<p><code>metaclass=keyword</code>是<code>Python3</code>才引入的，<code>Python2</code>中，必须使用<code>__metaclass__</code></p>
<p>&lt;!–code￼5–&gt;
</p>
<h4 id="Tombola的子类"><a href="#Tombola的子类" class="headerlink" title="Tombola的子类"></a>Tombola的子类</h4><p>&lt;!–code￼6–&gt;
</p>
<h4 id="Tombola的虚子类"><a href="#Tombola的虚子类" class="headerlink" title="Tombola的虚子类"></a>Tombola的虚子类</h4><p>&lt;!–code￼7–&gt;
</p>
<p>使用<code>@Tombola.register</code>注册作为<code>Tombola</code>的虚子类</p>
<p>注意因为注册了，所以<code>issubclass</code>和<code>isinstance</code>都能表现为<code>TomboList</code>是<code>Tombola</code>的子类。</p>
<p>但是打印继承关系</p>
<p>&lt;!–code￼8–&gt;
</p>
<p>可以看出<code>TomboList</code>并没有集成自<code>Tombola</code></p>
<h3 id="Tombola子类测试"><a href="#Tombola子类测试" class="headerlink" title="Tombola子类测试"></a>Tombola子类测试</h3><p>&lt;!–code￼9–&gt;
</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/05/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E6%8E%A5%E5%8F%A3/" data-id="cl45dkwg9003d69kc02rn7dfn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之序列切片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%BA%8F%E5%88%97%E5%88%87%E7%89%87/" class="article-date">
  <time datetime="2017-05-27T09:14:14.000Z" itemprop="datePublished">2017-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%BA%8F%E5%88%97%E5%88%87%E7%89%87/">深入理解Python之序列切片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文着重介绍</p>
<ul>
<li>基本序列协议: <code>__len__</code>和<code>__getitem__</code></li>
<li>带有多个条目对象的安全展示</li>
<li>合理的切片支持</li>
<li>哈希处理</li>
<li>自定义格式化语言拓展</li>
</ul>
<h3 id="Vector-自定义序列类型"><a href="#Vector-自定义序列类型" class="headerlink" title="Vector: 自定义序列类型"></a>Vector: 自定义序列类型</h3><p>&lt;!–code￼0–&gt;
</p>
<ul>
<li>使用<code>reprlib</code>来进行安全展示</li>
</ul>
<h3 id="协议和鸭子类型"><a href="#协议和鸭子类型" class="headerlink" title="协议和鸭子类型"></a>协议和鸭子类型</h3><p>为<code>Vector</code>实现<code>__len__</code>和<code>__getitem__</code>协议</p>
<p>&lt;!–code￼1–&gt;
</p>
<h4 id="增强切片功能"><a href="#增强切片功能" class="headerlink" title="增强切片功能"></a>增强切片功能</h4><p>&lt;!–code￼2–&gt;
</p>
<h3 id="动态属性访问"><a href="#动态属性访问" class="headerlink" title="动态属性访问"></a>动态属性访问</h3><p><code>__getattr__</code>当属性查找失败被调用。简单来说就是，给定表达式<code>my_obj.x</code>, <code>Python</code>检查对象是否含有<code>x</code>属性。如果没有，继续寻找类(<code>my_obj.__class__</code>)，然后继承链向上查找。如果依然没有找到<code>x</code>，那么<code>__getattr__</code>就会被调用</p>
<p>&lt;!–code￼3–&gt;
</p>
<h3 id="哈希和更快的-x3D-x3D"><a href="#哈希和更快的-x3D-x3D" class="headerlink" title="哈希和更快的&#x3D;&#x3D;"></a>哈希和更快的&#x3D;&#x3D;</h3><p>&lt;!–code￼4–&gt;
</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>&lt;!–code￼5–&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/05/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E5%BA%8F%E5%88%97%E5%88%87%E7%89%87/" data-id="cl45dkwg8003b69kc3jhhg47h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Python之自定义Python对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2017-05-20T08:25:39.000Z" itemprop="datePublished">2017-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%AF%B9%E8%B1%A1/">深入理解Python之自定义Python对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="对象展示"><a href="#对象展示" class="headerlink" title="对象展示"></a>对象展示</h3><p><code>Python</code>中有两种方式将对象以字符串的形式表示</p>
<p><code>repr()</code></p>
<blockquote>
<p>返回开发者想要到的字符串形式</p>
</blockquote>
<p><code>str()</code></p>
<blockquote>
<p>返回用户想要的字符串形式</p>
</blockquote>
<p>通过实现特殊的方法<code>__repr__</code>和<code>__str__</code>来支持<code>repr()</code>和<code>str()</code></p>
<p>有两个额外的方法来支持对象的展示形式<code>__bytes__</code>和<code>__format__</code>.<code>__byte__</code>方法和<code>__str__</code>类似，它被<code>bytes()</code>调用来显示对象的字节序列。<code>__format__</code>用于格式化对象显示</p>
<p>&lt;!–code￼0–&gt;
</p>
<h3 id="替代构造函数"><a href="#替代构造函数" class="headerlink" title="替代构造函数"></a>替代构造函数</h3><p>因为能够以字节的形式导出<code>Vector2d</code>，因此需要一个方法能够从二进制序列中导出一个对象。标准库<code>array</code>中有这么一个方法<code>frombytes</code></p>
<p>&lt;!–code￼1–&gt;
</p>
<h4 id="classmethod-vs-staticmethod"><a href="#classmethod-vs-staticmethod" class="headerlink" title="classmethod vs staticmethod"></a>classmethod vs staticmethod</h4><p><code>classmethod</code>对类而不是实例进行操作，其改变了方法调用的方式，它接受类自身作为第一个参数，最常用于替代构造函数</p>
<p><code>staticmethod</code>改变方法以便它收到的第一个参数不是特殊参数。静态方法就像一个纯净的函数存活在类中，而不是定义在模块层次</p>
<p>&lt;!–code￼2–&gt;
</p>
<h3 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h3><p>内置方法<code>format()</code>实际上调用<code>__format__(format_spec)</code>。</p>
<p>&lt;!–code￼3–&gt;
</p>
<ul>
<li>如果一个对象没有重写<code>__format__</code>那么将会调用<code>str()</code>，如果传入了格式化规格，那么会报错</li>
</ul>
<p>自定义格式化</p>
<p>&lt;!–code￼4–&gt;
</p>
<h3 id="Hashable-Vector2"><a href="#Hashable-Vector2" class="headerlink" title="Hashable Vector2"></a>Hashable Vector2</h3><p>&lt;!–code￼5–&gt;
</p>
<h3 id="Python中私有和保护的属性"><a href="#Python中私有和保护的属性" class="headerlink" title="Python中私有和保护的属性"></a>Python中私有和保护的属性</h3><p><code>Python</code>无法像<code>Java</code>那样创建<code>private</code>属性。但可以通过<code>__</code>前缀来表示属性是私有的,<code>_</code>用于表示受保护的</p>
<h3 id="使用-slot-节省空间"><a href="#使用-slot-节省空间" class="headerlink" title="使用__slot__节省空间"></a>使用__slot__节省空间</h3><p>默认情况，<code>Python</code>存储对象属性在<code>__dict__</code>。当你处理大数据量的时候，<code>__slots__</code>能够节省很多内存</p>
<p>&lt;!–code￼6–&gt;
</p>
<p>通过定义<code>__slots__</code>来告诉解释器，这是这个所有的属性，<code>Python</code>会将它们存在每个对象的一个类似<code>tuple</code>的结构中</p>
<h4 id="slots-的弊端"><a href="#slots-的弊端" class="headerlink" title="__slots__的弊端"></a>__slots__的弊端</h4><ul>
<li>必须为每个子类重新定义<code>__slots__</code>，因为继承属性会被忽略</li>
<li>对象只能拥有<code>__slots__</code>中的属性，除非将<code>__dict__</code>包括在<code>__slots__</code>中</li>
<li>对象不能够作为弱引用的目标，除非将<code>__weakref__</code>放到<code>__slots__</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xu6148152.github.io/2017/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Python%E5%AF%B9%E8%B1%A1/" data-id="cl45dkwgd003m69kc0wpifirw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-AOSP/" rel="tag">Android AOSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-source-analysis/" rel="tag">Android source analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%BA%90%E7%A0%81/" rel="tag">Android源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder-Hook-Android-Framework/" rel="tag">Binder Hook Android Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FFMpeg4-1-ndkr18b/" rel="tag">FFMpeg4.1 ndkr18b</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework-Hook/" rel="tag">Framework, Hook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hook-Framework-Android/" rel="tag">Hook, Framework, Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ionic-CI-Python/" rel="tag">Ionic, CI, Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-NIO/" rel="tag">Java NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-%E5%B9%B6%E5%8F%91/" rel="tag">Python, 并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">SpringCloud源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/" rel="tag">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-Channel/" rel="tag">golang Channel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">开源库源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Android-AOSP/" style="font-size: 10px;">Android AOSP</a> <a href="/tags/Android-source-analysis/" style="font-size: 10px;">Android source analysis</a> <a href="/tags/Android%E6%BA%90%E7%A0%81/" style="font-size: 10px;">Android源码</a> <a href="/tags/Binder-Hook-Android-Framework/" style="font-size: 10px;">Binder Hook Android Framework</a> <a href="/tags/FFMpeg4-1-ndkr18b/" style="font-size: 10px;">FFMpeg4.1 ndkr18b</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/Framework-Hook/" style="font-size: 10px;">Framework, Hook</a> <a href="/tags/Golang/" style="font-size: 10px;">Golang</a> <a href="/tags/Hook-Framework-Android/" style="font-size: 10px;">Hook, Framework, Android</a> <a href="/tags/Ionic-CI-Python/" style="font-size: 10px;">Ionic, CI, Python</a> <a href="/tags/Java-NIO/" style="font-size: 10px;">Java NIO</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/OpenGL/" style="font-size: 10px;">OpenGL</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/Python-%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">Python, 并发</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/SpringCloud%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">SpringCloud源码解析</a> <a href="/tags/ZooKeeper/" style="font-size: 10px;">ZooKeeper</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/golang-Channel/" style="font-size: 10px;">golang Channel</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库源码分析</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 13.33px;">源码分析</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">编程</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/08/fresco-memory-cache/">fresco之内存bitmap缓存</a>
          </li>
        
          <li>
            <a href="/2019/01/20/%E4%BD%BF%E7%94%A8NDK%E7%BC%96%E8%AF%91FFmpeg4-1/">使用NDK编译FFmpeg4.1</a>
          </li>
        
          <li>
            <a href="/2018/04/05/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/">Zookeeper源码分析之选举机制</a>
          </li>
        
          <li>
            <a href="/2018/04/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAZooKeeper/">深入浅出ZooKeeper</a>
          </li>
        
          <li>
            <a href="/2018/03/03/%E8%81%8A%E8%81%8AGo-Channel/">聊聊Go Channel</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Binea<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>