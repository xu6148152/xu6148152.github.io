<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xu6148152.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://xu6148152.github.io/page/5/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale">
<meta property="article:author" content="Binea">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://xu6148152.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"default","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Binea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/12/04/Animator-at-Android/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/04/Animator-at-Android/" class="post-title-link" itemprop="url">Animator at Android</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-12-04 21:17:02" itemprop="dateCreated datePublished" datetime="2016-12-04T21:17:02+08:00">2016-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2016-12-25 18:33:39" itemprop="dateModified" datetime="2016-12-25T18:33:39+08:00">2016-12-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h3><p>其是<code>Android3.0</code>之后加入的作用于对象属性的动画,<code>Animator</code>是所有属性动画的基类，其下有<code>ValueAnimator</code>,<code>AnimatorSet</code>,由<code>ValueAnimator</code>再拓展出<code>ObjectAnimator</code>,<code>TimeAnimator</code></p>
<p>其整体结构图</p>
<p><img data-src="/./animator.png" alt="animator"></p>
<h4 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h4><p>为作用对象提供简单的能够计算动画时间和值得时间引擎，它运行在自定义的<code>Handler</code>里面以确保所有的属性改变都会在<code>UI</code>线程。主要<code>API</code>:</p>
<p>&lt;!–code￼0–&gt;
</p>
<p>这些方法里面都是进行值得初始化</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>都是重新封装转化成<code>PropertyValuesHolder</code>，这是封装动画属性和值得对象，之后会详细介绍</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>设置估值器，最后也是由<code>PropertyValuesHolder</code>保存</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>开始动画的逻辑其实很简单，主要是判断动画是否需要反转。最终动画的更新交给<code>AnimationHandler</code></p>
<h5 id="AnimationHandler"><a href="#AnimationHandler" class="headerlink" title="AnimationHandler"></a>AnimationHandler</h5><p>处理所有运行中的动画的定时脉冲，这个机制能确保所有的动画都运行在<code>UI</code>线程，其使用<code>Choreograhper(用于调整动画输入和绘制的时机)</code>来执行周期的回调</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>流程图</p>
<p><img data-src="/./ValueAnimator.png" alt="ValueAnimator"></p>
<h4 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h4><p>插值器是描述动画变化的频率。其主要方法是  </p>
<p>&lt;!–code￼5–&gt;
</p>
<p>类关系图:<br><img data-src="/./interpolator.png" alt="interpolator"></p>
<p>系统已经为开发者准备了一些默认的插值器，我们来简单看下这些插值器的算法</p>
<h5 id="LinearInterpolator-线性插值器"><a href="#LinearInterpolator-线性插值器" class="headerlink" title="LinearInterpolator(线性插值器)"></a>LinearInterpolator(线性插值器)</h5><p>&lt;!–code￼6–&gt;
</p>
<p><img data-src="/./LinearInterpolator.png"></p>
<h5 id="AccelerateDecelerateInterpolator-加减速插值器"><a href="#AccelerateDecelerateInterpolator-加减速插值器" class="headerlink" title="AccelerateDecelerateInterpolator(加减速插值器)"></a>AccelerateDecelerateInterpolator(加减速插值器)</h5><p>&lt;!–code￼7–&gt;
</p>
<p><img data-src="/./AccelerateDecelerateInterpolator.png">  </p>
<p>其特性是在动画开始和结束阶段变化缓慢，中间阶段变化迅速</p>
<h5 id="AccelerateInterpolator-加速插值器"><a href="#AccelerateInterpolator-加速插值器" class="headerlink" title="AccelerateInterpolator(加速插值器)"></a>AccelerateInterpolator(加速插值器)</h5><p>&lt;!–code￼8–&gt;
</p>
<p><img data-src="/./AccelerateInterpolator.png"><br>其特点是动画变化速度一直加快，有个加速因子，默认为1。</p>
<h5 id="AnticipateInterpolator"><a href="#AnticipateInterpolator" class="headerlink" title="AnticipateInterpolator"></a>AnticipateInterpolator</h5><p>&lt;!–code￼9–&gt;
</p>
<p><img data-src="/./AnticipateInterpolator.png"></p>
<h5 id="AnticipateOvershootInterpolator"><a href="#AnticipateOvershootInterpolator" class="headerlink" title="AnticipateOvershootInterpolator"></a>AnticipateOvershootInterpolator</h5><p>&lt;!–code￼10–&gt;
</p>
<p><img data-src="/./AnticipateOvershootinterpolator.png"></p>
<p>还有很多别的插值器。这里就不多加赘述了。只要将相应的算法写入<code>getInterpolation</code>中即可</p>
<p>使用的地方</p>
<p>&lt;!–code￼11–&gt;
</p>
<h4 id="TypeEvaluator-估值器"><a href="#TypeEvaluator-估值器" class="headerlink" title="TypeEvaluator(估值器)"></a>TypeEvaluator(估值器)</h4><p>根据当前的动画频率，起始值，结束值计算当前值</p>
<p><img data-src="/./TypeEvaluator.png"></p>
<p>&lt;!–code￼12–&gt;
</p>
<h5 id="ArgbEvaluator"><a href="#ArgbEvaluator" class="headerlink" title="ArgbEvaluator"></a>ArgbEvaluator</h5><p>&lt;!–code￼13–&gt;
</p>
<p>算法是线性函数，主要因子<code>fraction</code>来自插值器的计算, <code>y= a + kx</code></p>
<h5 id="IntEvaluator"><a href="#IntEvaluator" class="headerlink" title="IntEvaluator"></a>IntEvaluator</h5><p>&lt;!–code￼14–&gt;
</p>
<p>估值器主要实在<code>KeyFrames</code>中使用，而<code>KeyFrames</code>存在<code>PropertyValuesHolder</code>当中，最终<code>Choreographer</code>来更新动画使用</p>
<h4 id="Choreograhper"><a href="#Choreograhper" class="headerlink" title="Choreograhper"></a>Choreograhper</h4><p>协调动画，输入和绘制的时间。其会收到来自显示系统的定时脉冲，然后安排工作作为下一帧渲染的一部分。</p>
<p>&lt;!–code￼15–&gt;
</p>
<ul>
<li>初始化，创建<code>FrameHandler</code>，创建回调队列</li>
</ul>
<p>&lt;!–code￼16–&gt;
</p>
<ul>
<li>将回调加入回调队列，如果没有延时，锁定当前帧，如果使用<code>VSYNC</code>，诺当前运行在相同的线程，直接通过<code>FrameDisplayEventReceiver</code>要求同步，其他情况发送消息到<code>Handler</code>中执行。<code>Handler</code>处理三种消息,<code>MSG_DO_FRAME</code>,<code>MSG_DO_SCHEDULE_VSYNC</code>, <code>MSG_DO_SCHEDULE_CALLBACK</code></li>
</ul>
<p>&lt;!–code￼17–&gt;
</p>
<ul>
<li><code>MSG_DO_FRAME</code>:判断当前帧时间，低于上次绘制时间，要求同步。否则调用<code>doCallbacks</code>，执行回调队列中的回调</li>
</ul>
<h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><h4 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h4><p>支持对目标对象的属性做动画，对<code>ValueAnimator</code>的拓展</p>
<p>&lt;!–code￼18–&gt;
</p>
<ul>
<li><code>ObjectAnimator</code>比<code>ValueAnimator</code>多了<code>target</code>和<code>Property</code>，这些信息都在<code>PropertyValuesHolder</code>,必须要要有getter&#x2F;setter才能更新目标对象</li>
</ul>
<h4 id="PropertyValuesHolder-处理setter-getter的寻找"><a href="#PropertyValuesHolder-处理setter-getter的寻找" class="headerlink" title="PropertyValuesHolder 处理setter, getter的寻找"></a>PropertyValuesHolder 处理setter, getter的寻找</h4><p>&lt;!–code￼19–&gt;
</p>
<ul>
<li><code>PropertyValuesHolder</code>主要持有动画的相关属性信息，包括关键帧集，插值器，估值器等</li>
</ul>
<h4 id="KeyFrame"><a href="#KeyFrame" class="headerlink" title="KeyFrame"></a>KeyFrame</h4><p>动画关键帧，保存动画某一帧的时间&#x2F;值。被<code>ValueAnimator</code>使用来计算两个值之间的动画值。<code>PropertyValuesHolder</code>保存了<code>KeyFrames</code>其保存了多个<code>KeyFrame</code>。简单来说<code>KeyFrame</code>就是我们做动画的起始值，中间值，结束值，这些都是由开发者定义。</p>
<p>&lt;!–code￼20–&gt;
</p>
<ul>
<li>动画至少会包含两个关键帧，一个起始关键帧，一个结束关键帧。中间有多少关键帧由开发者自行定义</li>
</ul>
<h4 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h4><p>允许同时播放多个动画或者定义动画的播放顺序</p>
<p>&lt;!–code￼21–&gt;
</p>
<ul>
<li>流程: <ol>
<li>首先禁止异步运行动画，设置所有动画的时间和插值器。</li>
<li>对所有的动画进行排序(根据依赖关系),取消所有老的监听。如果动画没有依赖，加入即将开始的动画队列，否则创建依赖监听，创建临时依赖</li>
<li>没有延时，启动动画。否则创建延时动画，延时动画结束后，后续动画开始</li>
<li>动画开始监听回调，如果没有动画，动画结束监听回调</li>
</ol>
</li>
</ul>
<p>&lt;!–code￼22–&gt;
</p>
<ul>
<li>包含两个规则，一起，后续</li>
</ul>
<p>&lt;!–code￼23–&gt;
</p>
<h4 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h4><p><code>ViewGroup</code>布局发生改变时播放动画。这个动画的核心概念是两个类型的改变会引起四种不同的动画运行。这两种改变时<code>appearing</code>和<code>disappearing</code>。</p>
<p>&lt;!–code￼24–&gt;
</p>
<p>动画类型，用一个字节表示</p>
<p>&lt;!–code￼25–&gt;
</p>
<ul>
<li>主要流程<ol>
<li>启动一个延时动画来移除为执行的动画</li>
<li>监听布局变化,如果是<code>ValueAnimator</code>，判断起始帧和结束帧是否一样，如果一样表示结束.否则根据布局改变的原因设置动画类型，开始动画</li>
<li>移除缓存动画</li>
</ol>
</li>
</ul>
<h4 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h4><p>自动优化<code>View</code>对象的属性动画。如果想做1个或者两个属性动画，使用<code>ObjectAnimator</code>，其也可以设置属性值，合理的刷新视图。但是如果有多个属性要同时动画，或者想要使用更简洁的语法，那么可以使用<code>ViewPropertyAnimator</code></p>
<p>&lt;!–code￼26–&gt;
</p>
<ul>
<li>上述流程, 做属性动画都会调用<code>animateProperty</code>，其内部会调用<code>animatePropertyBy</code><ol>
<li>首先会取消这个属性上存在的动画</li>
<li>构建<code>NameValuesHolder</code></li>
<li>调用<code>removeCallbacks(runnable)</code>，取消之前动画</li>
<li>调用<code>postOnAnimation(runnable)</code>，开始动画</li>
</ol>
</li>
</ul>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>主要用于做转场动画，其会保存场景转变的信息。任何转变有两个主要工作: 1. 捕获属性值 2. 基于捕获的属性值改变做动画。**无法与<code>TextureView</code>和<code>SurfaceView</code>一起使用。对于<code>SurfaceView</code>，由于其是从非UI线程更新UI，因此会造成不同步。对于<code>TextureView</code>，由于转场动画依赖<code>ViewOverlay</code>，而其又无法与<code>TextureView</code>一起工作。</p>
<h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img data-src="/./transition.png" alt="transition"></p>
<p>&lt;!–code￼27–&gt;
</p>
<h5 id="开始转场动画"><a href="#开始转场动画" class="headerlink" title="开始转场动画"></a>开始转场动画</h5><p>&lt;!–code￼28–&gt;
</p>
<ul>
<li>流程<ol>
<li>未设置<code>Transition</code>，使用默认<code>Transition</code>，也就是<code>AutoTransition</code></li>
<li>暂停当前正在运行的转场动画，捕获当前场景，取消之前的转场动画</li>
<li>设置当前场景</li>
<li>设置绘制(<code>preDraw</code>)监听，在其当中捕获场景和开始转场动画</li>
</ol>
</li>
</ul>
<h5 id="AutoTransition"><a href="#AutoTransition" class="headerlink" title="AutoTransition"></a>AutoTransition</h5><p>组合转场动画，包括渐变和区域改变。<code>Transition</code>由<code>TransitionManger</code>管理。一般可以使用<code>beginDelayedTransition</code>开始一个转场动画，默认的转场动画为<code>AutoTransition</code>:</p>
<p>&lt;!–code￼29–&gt;
</p>
<p>效果如下:</p>
<p>&lt;!–swig￼49–&gt;
</p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><blockquote>
<p>继承自TransitionSet</p>
</blockquote>
<p>&lt;!–code￼30–&gt;
</p>
<ul>
<li>顺序播放渐出，区域变化，渐入动画</li>
</ul>
<h5 id="TransitionSet"><a href="#TransitionSet" class="headerlink" title="TransitionSet"></a>TransitionSet</h5><blockquote>
<p>继承自Transition</p>
</blockquote>
<p>&lt;!–code￼31–&gt;
</p>
<ul>
<li>调用各个<code>Transition</code>的方法</li>
</ul>
<p>&lt;!–code￼32–&gt;
</p>
<ul>
<li>使用各自<code>Transition</code>创建动画。为第一个转场动画设置必要的延时</li>
</ul>
<p>&lt;!–code￼33–&gt;
</p>
<ul>
<li>动画开始，由各个<code>Transition</code>开始动画，在这里会区分动画是串行播放，还是并行播放。</li>
</ul>
<h5 id="ChangeText-自定义transition"><a href="#ChangeText-自定义transition" class="headerlink" title="ChangeText(自定义transition)"></a>ChangeText(自定义transition)</h5><p>&lt;!–swig￼50–&gt;
</p>
<p>&lt;!–code￼34–&gt;
</p>
<ul>
<li>上述代码也能实现相同的功能，<code>ChangeText</code>只是对其进行了进一步的封装。这里不分析其源码</li>
</ul>
<h5 id="ChangeBound"><a href="#ChangeBound" class="headerlink" title="ChangeBound"></a>ChangeBound</h5><p>&lt;!–swig￼51–&gt;
</p>
<h6 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h6><blockquote>
<p>继承<code>Transition</code></p>
</blockquote>
<p>&lt;!–code￼35–&gt;
</p>
<ul>
<li>保存当前<code>View</code>的边界状态</li>
</ul>
<blockquote>
<p>创建动画，代码很长，核心代码</p>
</blockquote>
<p>&lt;!–code￼36–&gt;
</p>
<ul>
<li>主要功能是判断<code>View</code>的边界有没有发生改变，如果发生改变，使用对应的位置变化动画，主要包括<code>topLeft, bottomRight, position</code>。如果没有发生改变，则在<code>View</code>上绘制<code>Overlay</code>并对其做<code>path</code>动画。</li>
</ul>
<p>设置<code>pathMotion</code></p>
<blockquote>
<p>其是一个抽象类，用于描述<code>Transition</code>的<code>Path</code>信息</p>
</blockquote>
<p>&lt;!–swig￼52–&gt;
</p>
<p>&lt;!–code￼37–&gt;
</p>
<ul>
<li>实现<code>getPath</code>以便提供两点之间的变化频率</li>
</ul>
<h5 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h5><blockquote>
<p>继承自<code>Visibility</code></p>
</blockquote>
<p>&lt;!–swig￼53–&gt;
</p>
<h6 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h6><p>&lt;!–code￼38–&gt;
</p>
<ul>
<li>保存当前<code>View</code>位置</li>
</ul>
<blockquote>
<p>其<code>createAnimator</code>在父类<code>Visibility</code>中被重写，当中调用<code>onAppear</code>和<code>onDisappear</code>，这两个方法分别有各自的重载方法，由子类提供具体的实现，默认无动画</p>
</blockquote>
<p>&lt;!–code￼39–&gt;
</p>
<ul>
<li>使用<code>CalculateSlide</code>接口的实现计算<code>View</code>离开或者进入场景时的位置，最后由<code>TranslationAnimationCreator</code>创建动画</li>
</ul>
<h5 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h5><p>&lt;!–swig￼54–&gt;
</p>
<p>设置<code>alpha</code></p>
<p>&lt;!–swig￼55–&gt;
</p>
<h6 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h6><p>private Animator createAnimation(final View view, float startScale, float endScale, TransitionValues values) {
        final float initialScaleX &#x3D; view.getScaleX();
        final float initialScaleY &#x3D; view.getScaleY();
        float startScaleX &#x3D; initialScaleX * startScale;
        float endScaleX &#x3D; initialScaleX * endScale;
        float startScaleY &#x3D; initialScaleY * startScale;
        float endScaleY &#x3D; initialScaleY * endScale;</p>
<pre><code>    if (values != null) &#123;
        Float savedScaleX = (Float) values.values.get(PROPNAME_SCALE_X);
        Float savedScaleY = (Float) values.values.get(PROPNAME_SCALE_Y);
        // if saved value is not equal initial value it means that previous
        // transition was interrupted and in the onTransitionEnd
        // we&#39;ve applied endScale. we should apply proper value to
        // continue animation from the interrupted state
        if (savedScaleX != null &amp;&amp; savedScaleX != initialScaleX) &#123;
            startScaleX = savedScaleX;
        &#125;
        if (savedScaleY != null &amp;&amp; savedScaleY != initialScaleY) &#123;
            startScaleY = savedScaleY;
        &#125;
    &#125;

    view.setScaleX(startScaleX);
    view.setScaleY(startScaleY);

    Animator animator = TransitionUtils.mergeAnimators(
            ObjectAnimator.ofFloat(view, View.SCALE_X, startScaleX, endScaleX),
            ObjectAnimator.ofFloat(view, View.SCALE_Y, startScaleY, endScaleY));
    addListener(new TransitionListenerAdapter() &#123;
        @Override
        public void onTransitionEnd(Transition transition) &#123;
            view.setScaleX(initialScaleX);
            view.setScaleY(initialScaleY);
        &#125;
    &#125;);
    return animator;
</code></pre>
<p>}</p>
<ul>
<li>合并<code>x, y</code>缩放的动画，合并是采用<code>TransitionSet</code>，如下</li>
</ul>
<p>&lt;!–code￼40–&gt;
</p>
<h5 id="Explode"><a href="#Explode" class="headerlink" title="Explode"></a>Explode</h5><blockquote>
<p>继承自Visibility</p>
</blockquote>
<p>&lt;!–swig￼56–&gt;
</p>
<h6 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h6><p>&lt;!–code￼41–&gt;
</p>
<ul>
<li>通过<code>calculateOut</code>计算扩散的距离，使用<code>TranslationAnimationCreator</code>创建动画</li>
</ul>
<p>&lt;!–code￼42–&gt;
</p>
<ul>
<li>计算场景动画的偏移量，如果为0，随机算出偏移量，算出x, y偏移量的平方根，求出最大距离<h5 id="TransitionName"><a href="#TransitionName" class="headerlink" title="TransitionName"></a>TransitionName</h5></li>
</ul>
<blockquote>
<p>设置要做动画的标识，在之后的动画中会对这些标识的<code>View</code>做动画</p>
</blockquote>
<p>&lt;!–swig￼57–&gt;
</p>
<h5 id="ImageTransform"><a href="#ImageTransform" class="headerlink" title="ImageTransform"></a>ImageTransform</h5><p>&lt;!–swig￼58–&gt;
</p>
<h5 id="ReColor"><a href="#ReColor" class="headerlink" title="ReColor"></a>ReColor</h5><p>&lt;!–swig￼59–&gt;
</p>
<h5 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h5><blockquote>
<p>继承自Transition的旋转动画</p>
</blockquote>
<p>&lt;!–swig￼60–&gt;
</p>
<h6 id="源码分析-5"><a href="#源码分析-5" class="headerlink" title="源码分析"></a>源码分析</h6><p>&lt;!–code￼43–&gt;
</p>
<ul>
<li>创建旋转动画</li>
</ul>
<h5 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h5><p>&lt;!–swig￼61–&gt;
</p>
<h5 id="Change-Scene"><a href="#Change-Scene" class="headerlink" title="Change Scene"></a>Change Scene</h5><p>&lt;!–swig￼62–&gt;
</p>
<h6 id="源码分析-6"><a href="#源码分析-6" class="headerlink" title="源码分析"></a>源码分析</h6><p>&lt;!–code￼44–&gt;
</p>
<ul>
<li>先淡出效果(<code>Fade</code>)，改变区域(<code>ChangeBound</code>)，淡入效果(<code>Fade</code>)</li>
</ul>
<h5 id="Fade"><a href="#Fade" class="headerlink" title="Fade"></a>Fade</h5><p>渐变转场动画，继承自<code>Visibility</code></p>
<p>&lt;!–code￼45–&gt;
</p>
<ul>
<li>捕获初始场景的<code>alpha</code>值</li>
</ul>
<p>&lt;!–code￼46–&gt;
</p>
<ul>
<li>创建渐变属性动画，其会由<code>onAppear()</code>和<code>onDisAppear</code>调用</li>
</ul>
<p>&lt;!–code￼47–&gt;
</p>
<ul>
<li>这两个方法由<code>Visibility</code>的<code>createAnimator</code>调用</li>
</ul>
<p>&lt;!–code￼48–&gt;
</p>
<ul>
<li><code>View</code>显示或隐藏时会创建对应的渐变动画。<code>Transition</code>的<code>playTransition</code>会调用<code>createAnimators</code>，其内部会调用<code>createAnimator</code>。</li>
<li>整体流程是启动<code>Transition</code>-&gt;创建动画(<code>createAnimators</code>)-&gt;创建单个动画(<code>createAnimator</code>由<code>Transition</code>子类实现,默认空)-&gt;<code>Visibility</code>的<code>onAppear()</code>&#x2F;<code>onDisappear</code>-&gt;子类<code>createAnimator</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><blockquote>
<p><code>Transition</code>动画其实是对属性动画的一种高级封装。其主要流程是<code>TransitionManager</code>调用<code>beginDelayedTransition</code>,内部监听了<code>OnPreDrawListener</code>，其在<code>onPreDraw</code>调用<code>captureView</code>用于获取当前<code>View</code>的状态,调用<code>playTransition</code>开始转场动画。之后创建动画<code>createAnimator</code>。这其中<code>captureView</code>都是由子类实现，而<code>createAnimator</code>则可以由子类选择重写。最终动画的开始还有调用<code>animator.start()</code></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/12/03/Picasso%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/03/Picasso%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Picasso解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2016-12-03 17:59:43 / Modified: 18:04:22" itemprop="dateCreated datePublished" datetime="2016-12-03T17:59:43+08:00">2016-12-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Picasso</code>是常用的图片加载库，其有很多设计上值得学习的地方，比如根据网络调整线程池大小，批量处理图片结果，以及消息分发。文本会对它进行深入分析</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>&lt;!–code￼0–&gt;
</p>
<ul>
<li><code>Adapter</code>内下载</li>
<li>图片转换</li>
<li>预置图片</li>
<li>资源加载</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>&lt;!–code￼1–&gt;
</p>
<ul>
<li>创建<code>Picasso</code>对象</li>
</ul>
<p>&lt;!–code￼2–&gt;
</p>
<ul>
<li>创建默认下载器</li>
<li>创建默认缓存,<code>LRU</code>缓存</li>
<li>自定义线程池</li>
<li>创建默认请求转换器</li>
<li>创建分配器</li>
</ul>
<p>&lt;!–code￼3–&gt;
</p>
<ul>
<li>判断需要的资源是否有缓存，没有，创建请求，进入队列</li>
<li>进入队列后，会由<code>Dispatcher</code>分发请求</li>
<li><code>Dispatcher</code>内有有个<code>Handler</code>用于消息分发，有个主线程<code>Handler</code>用于通知主线程刷新UI</li>
</ul>
<p>&lt;!–code￼4–&gt;
</p>
<ul>
<li>判断请求动作是否包含在暂停里面</li>
<li>判断是否已经存在<code>hunterMap</code></li>
<li>加入<code>hunterMap</code></li>
</ul>
<p>&lt;!–code￼5–&gt;
</p>
<ul>
<li>解码图片，按需求设置转换器，分发结果</li>
</ul>
<p>&lt;!–code￼6–&gt;
</p>
<p>整体流程大概是</p>
<ul>
<li><p>创建<code>RequestHandler</code>-&gt;进入队列-&gt;分发请求-&gt;分发结果-&gt;通知主线程</p>
</li>
<li><p>这里面<code>Dispatcher</code>起到请求和结果分发器的作用内部。一个线程池，两个<code>Handler</code>。线程池默认3个线程。会根据网络状况自动调整线程数量</p>
<ul>
<li><code>WIFI</code>，以太网会有四个线程池</li>
<li>移动网络: 4G，三个线程池，3G两个线程池,2G一个线程池</li>
</ul>
</li>
<li><p><code>Dispatcher</code>会批量打包结果一起通知主线程</p>
</li>
</ul>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img data-src="/./picasso_architecture.png" alt="picasso"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/10/14/How-Does-Instant-Run-Work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/10/14/How-Does-Instant-Run-Work/" class="post-title-link" itemprop="url">How Does Instant Run Work</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-10-14 15:04:05" itemprop="dateCreated datePublished" datetime="2016-10-14T15:04:05+08:00">2016-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2016-12-14 15:06:43" itemprop="dateModified" datetime="2016-12-14T15:06:43+08:00">2016-12-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f#.89kk542oe">原文</a></p>
<p><code>Instant Run</code>，<code>Android Studio</code>的一项神奇的功能，用于减少增量代码的构建和部署时间。它看起来很神奇。你首次运行或者调试，你就如你预期般的那样工作，之后每次代码的改动，会花很少的时间去构建和部署</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>构建图</p>
<p><img data-src="/./instant_run_build.png" alt="instant build"> </p>
<p><code>Instant Run</code>的目标很简单</p>
<blockquote>
<p><em><strong>移除尽可能多的步骤，使剩下的东西尽可能快</strong></em></p>
</blockquote>
<p>具体是:</p>
<ul>
<li>只构建和部署新增的东西</li>
<li>不重新安装应用</li>
<li>不重新启动应用</li>
<li>不重新启动<code>Activity</code></li>
</ul>
<h4 id="热部署，温部署，冷部署"><a href="#热部署，温部署，冷部署" class="headerlink" title="热部署，温部署，冷部署"></a>热部署，温部署，冷部署</h4><p><img data-src="/./hot_warm_cold.png" alt="hot_warm_cold"></p>
<p><strong>热部署</strong>: 部署新的改变，不需要重新应用，甚至不需要重启当前<code>Activity</code>。能用于方法内简单的改变</p>
<p><strong>温部署</strong>: <code>Activity</code>需要重启后，新的改变才能生效。通常用于资源改变</p>
<p><strong>冷部署</strong>: 应用重启，但不重新安装。任何结构型变化，如继承关系或者方法签名会使用冷部署</p>
<h4 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h4><p><img data-src="/./merged_combined.png" alt="merged_combined"></p>
<p><code>manifest</code>文件被合并，打包。伴随着资源一起打包进<code>APK</code>。<code>java</code>源代码被编译成<code>字节码</code>，转换成<code>.dex</code>文件。它们也会打包进入<code>APK</code></p>
<p><strong>首次点击运行或调试(<code>Instant Run</code>打开), <code>Gradle</code>做的额外操作</strong></p>
<p><img data-src="/./first_run_instant_run.png" alt="first_run_instant_run"> </p>
<p>字节码被添加到<code>.class</code>文件中，一个新的<code>App Server</code>类被注入到<code>app</code>中</p>
<p>一个新的<code>Application</code>类定义也被加入到<code>App</code>，注入自定义类加载器以及将启动<code>App Server</code>。一般来说，<code>manifest</code>会被修改以便<code>app</code>能使用(如果你创建了自己的<code>Application</code>类，<code>Instant Run</code>版本会代理这个<code>Application</code>类)</p>
<p>这时<code>Instant Run</code>运行了。因此如果你改变了代码，<code>Instant Run</code>会尝试避免使用热，温，冷部署来避免全构建</p>
<blockquote>
<p>应用<code>Instant Run</code>改变之前，<code>as</code>会检查<code>Instant Run</code>内是否有一个打开的<code>Socket</code>连接着<code>App Server</code></p>
</blockquote>
<h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><p><img data-src="/./hot_swapping.png" alt="hot_swapping"></p>
<p><code>as</code>监控开发过程中哪些字段被修改了。运行自定义<code>Gradle</code>任务来未修改的类生成<code>.dex</code>文件</p>
<p>这些新<code>.dex</code>文件被<code>as</code>挑选，并部署到<code>app</code>中的<code>App Server</code></p>
<p>由于类的原始版本已经存在了，<code>Gradle</code>转换更新版本以便高效覆盖这些之前存在的类。转换结束，更新的类被<code>App Server</code>使用自定义的类加载器加载。</p>
<p>从现在起，每次方法被调用，这个注入到原始类文件中的监控类都会检查是否已经更新。如果更新了，那么后续操作会代理到新的覆盖类中。</p>
<h4 id="温部署"><a href="#温部署" class="headerlink" title="温部署"></a>温部署</h4><p>温部署重启<code>Activity</code>。当<code>Activity</code>启动，资源被加载。因此更新资源需要重启<code>Acitivty</code>以便强制资源重新加载</p>
<p>当前，任何资源的改变会导致，所有的资源被重新打包到<code>app</code>，但使用增量打包器会只打包和部署更改的资源</p>
<blockquote>
<p>注意温部署对于<code>manifest</code>的改变是无效的，因为<code>manifest</code>信息的读取实在<code>apk</code>安装的时候。<code>manifest</code>的改变会触发全量构建和部署</p>
</blockquote>
<h4 id="冷部署"><a href="#冷部署" class="headerlink" title="冷部署"></a>冷部署</h4><p>部署后，<code>app</code>和其子项目被分成10个片段，每个片段有自己的<code>dex</code>文件。类安装它们的包名分割。使用冷部署，修改类会要求所有其他在相同片段中的类重新加载。</p>
<p>这个策略依赖于运行时加载多个<code>dex</code>文件的能力。<code>5.0</code>以上采用<code>ART</code>具备这种能力。之下会采用全量构建部署</p>
<h4 id="Instant-Run技巧和提示"><a href="#Instant-Run技巧和提示" class="headerlink" title="Instant Run技巧和提示"></a><code>Instant Run</code>技巧和提示</h4><ul>
<li><code>manifest</code>的修改会导致全量构建部署</li>
<li><code>Instant Run</code>值监控主进程，如果<code>app</code>使用多进程。热部署和温部署在其他进程中会降到冷部署，如果低于5.0，会采用全量构建部署</li>
<li><code>Windows</code>防火墙可能会导致<code>Instant Run</code>无法启动</li>
<li><code>Instant Run</code>不支持<code>Jack</code>编译器</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/10/03/Retrofit%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/10/03/Retrofit%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-10-03 16:39:08" itemprop="dateCreated datePublished" datetime="2016-10-03T16:39:08+08:00">2016-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2016-11-11 11:56:01" itemprop="dateModified" datetime="2016-11-11T11:56:01+08:00">2016-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Retrofit分析"><a href="#Retrofit分析" class="headerlink" title="Retrofit分析"></a><code>Retrofit</code>分析</h3><p><code>Retrofit</code>可以当做是<code>OkHttp3</code>的应用层。其接收<code>Java</code>注解的请求。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>&lt;!–code￼0–&gt;
</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>&lt;!–code￼1–&gt;
</p>
<p><code>create</code>方法接收客户端定义的<code>api</code>接口   </p>
<p>主要工作：  </p>
<ol>
<li>使用代理模式创建出接口对应的类</li>
<li>加载接口里面的方法，并缓存</li>
<li>如果方法不存在，创建<code>ServiceMethod</code>，并缓存</li>
<li>使用<code>API</code>接口的方法创建<code>OkHttpCall</code></li>
<li>将<code>okHttpCall</code>与<code>callAdapter</code>关联</li>
</ol>
<h5 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h5><p>&lt;!–code￼2–&gt;
</p>
<p>主要工作:</p>
<ol>
<li>创建请求适配器</li>
<li>创建响应适配器</li>
<li>解析方法注解</li>
<li>解析参数注解</li>
</ol>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img data-src="/./retrofit.png" alt="Retrofit"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/09/25/Load-SO-from-sdcard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/25/Load-SO-from-sdcard/" class="post-title-link" itemprop="url">Load .SO from sdcard</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-09-25 14:17:46" itemprop="dateCreated datePublished" datetime="2016-09-25T14:17:46+08:00">2016-09-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&lt;!–code￼0–&gt;
</p>
<p>C代码:  </p>
<p>&lt;!–code￼1–&gt;
</p>
<p>从上述代码可以看出关键代码在于<code>LoadNativeLibrary </code>  </p>
<p>&lt;!–code￼2–&gt;</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/09/16/WindowManager%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/16/WindowManager%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">WindowManager分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-09-16 16:45:09" itemprop="dateCreated datePublished" datetime="2016-09-16T16:45:09+08:00">2016-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2016-09-17 14:03:38" itemprop="dateModified" datetime="2016-09-17T14:03:38+08:00">2016-09-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p><code>WindowManager</code>是整个绘制系统的核心桥梁。一般通过<code>getSystemService(Context.WindowService)</code>可以获取。</p>
<p>&lt;!–code￼0–&gt;
</p>
<h4 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h4><p>通过代码可以发现<code>WindowManagerImpl</code>的核心实现都在<code>WindowManagerGlobal</code></p>
<h4 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h4><p>&lt;!–code￼1–&gt;
</p>
<p>可以发现<code>addView</code>里面主要用到<code>ViewRootImpl</code>来添加视图</p>
<h4 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h4><p>&lt;!–code￼2–&gt;
</p>
<p>通过<code>AIDL</code>获取<code>WindowManagerService</code>这时<code>Framework</code>与<code>Native</code>建立起连接了。之后<code>ViewRootImpl</code>会调用<code>setView</code>。</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>要求系统开始布局</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>通过<code>Choreographer</code>发送绘制命令<code>CALLBACK_TRAVERSAL</code>要求系统开始绘制</p>
<p>&lt;!–code￼5–&gt;
</p>
<h4 id="performMeasure"><a href="#performMeasure" class="headerlink" title="performMeasure"></a>performMeasure</h4><p>&lt;!–code￼6–&gt;
</p>
<p><code>performMeasure</code>会调用<code>view.measure()</code>里面会去调用<code>onMeasure</code>，这里会去真正的做测量操作</p>
<h4 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h4><p>&lt;!–code￼7–&gt;
</p>
<p>先进行布局，检查需要布局的数目，检查这些布局请求是否合理,不合理重新布局。</p>
<h4 id="performDraw"><a href="#performDraw" class="headerlink" title="performDraw"></a>performDraw</h4><p>&lt;!–code￼8–&gt;
</p>
<p>判断此次绘制是否取消或者是新的页面。</p>
<p>&lt;!–code￼9–&gt;
</p>
<p>cavas绘制</p>
<p>&lt;!–code￼10–&gt;
</p>
<p>uml</p>
<p><img data-src="/./WindowManager.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/09/15/LayoutInflater%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/15/LayoutInflater%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">LayoutInflater分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2016-09-15 14:58:38 / Modified: 15:10:47" itemprop="dateCreated datePublished" datetime="2016-09-15T14:58:38+08:00">2016-09-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h4><p>加载布局的时候经常会用到</p>
<p>&lt;!–code￼0–&gt;
</p>
<p>或者</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>关键就是<code>LayoutInflater</code>，它是通过</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>因此可以看出它其实属于系统的一种服务。由此我们来分析当使用系统服务时都做了什么？</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>由源码我能知道获取系统服务总是通过</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>因此在<code>ContextImpl</code>找到</p>
<p>&lt;!–code￼4–&gt;
</p>
<h5 id="SystemServiceRegistry"><a href="#SystemServiceRegistry" class="headerlink" title="SystemServiceRegistry"></a>SystemServiceRegistry</h5><p>&lt;!–code￼5–&gt;
</p>
<p><code>SYSTEM_SERVICE_FETCHERS</code>是个<code>Map</code>容器，保存着<code>ServiceFetcher</code></p>
<p>从<code>SystemServiceRegistry</code>可以看出，我们平时所需要的系统服务都会在一开始的注册</p>
<p>&lt;!–code￼6–&gt;
</p>
<h5 id="ServiceFetcher"><a href="#ServiceFetcher" class="headerlink" title="ServiceFetcher"></a>ServiceFetcher</h5><p>&lt;!–code￼7–&gt;
</p>
<p>这里每次获取服务的时候都会进行缓存检查确保只会存在一个相同的服务</p>
<p>下面是uml图
<img data-src="/./uml.png" alt="getSystemService"></p>
<p>&lt;!–code￼8–&gt;
</p>
<p>上述代码会注册<code>LayoutInflayer</code>服务，可以看出实际的实现在<code>PhoneLayoutInflayer</code>，其继承自<code>LayoutInflayer</code>。</p>
<p>&lt;!–code￼9–&gt;
</p>
<p>主要加载视图的主要步骤:</p>
<p>解析<code>xml</code>根元素，根元素如果是<code>merge</code>直接调用<code>rInflate</code>,<code>root</code>作为根节点。否则调用<code>createViewFromTag</code>加载视图,然后挂到根节点下</p>
<p>&lt;!–code￼10–&gt;
</p>
<p>通过Factory或者Factory2加载视图(主要用于Fragment)，之后如果是内置<code>View</code>调用<code>onCreateView</code>，然后调用<code>createView</code>，自定义<code>View</code>直接调用<code>createView</code>。</p>
<p>&lt;!–code￼11–&gt;
</p>
<p><code>createView</code>首先从<code>sConstructorMap</code>中取出缓存的<code>View</code>构造器，如果不存在直接通过反射创建实例，还可以通过<code>Filter</code>来控制加载的<code>View</code>。</p>
<h5 id="rInflate"><a href="#rInflate" class="headerlink" title="rInflate()"></a>rInflate()</h5><p>&lt;!–code￼12–&gt;
</p>
<blockquote>
<p>解析顺序是<code>&lt;requestFocus/&gt;</code>-&gt;<code>&lt;tag&gt;</code>-&gt;<code>&lt;include&gt;</code>-&gt;<code>&lt;merge&gt;</code>-&gt;<code>&lt;View&gt;</code></p>
</blockquote>
<h4 id="LayoutInflater-uml"><a href="#LayoutInflater-uml" class="headerlink" title="LayoutInflater uml"></a>LayoutInflater uml</h4><p><img data-src="/./LayoutInflater.png" alt="getSystemService"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/07/24/Design_pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/07/24/Design_pattern/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-07-24 15:13:45" itemprop="dateCreated datePublished" datetime="2016-07-24T15:13:45+08:00">2016-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2016-11-16 13:43:27" itemprop="dateModified" datetime="2016-11-16T13:43:27+08:00">2016-11-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/xu6148152/Design-Patterns">代码示例</a>   </p>
<blockquote>
<ol>
<li>单一职责原则</li>
<li>接口隔离(多用组合，少用继承)</li>
<li>依赖倒置(高层不依赖低层，都依赖抽象)</li>
<li>里氏替换(子类必须能够替换基类)</li>
<li>迪米特原则(解耦，类之间尽量减少联系)</li>
<li>开闭原则(开放拓展，关闭修改)</li>
</ol>
</blockquote>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote>
<ol>
<li>封装变化</li>
<li>针对接口编程(针对超类型编程)，而不是针对实现编程</li>
<li>多用组合，少用继承</li>
<li>为了交互对象之间的松耦合设计而努力</li>
<li>对拓展开放，对修改关闭</li>
<li>最少知识(墨忒耳法则(Law of Demeter))</li>
<li>好莱坞原则，别调用我们，我们会调用你</li>
<li>一个类应该只有一个引起变化的原因</li>
<li>依赖倒置原则(不能让高层组件依赖低层组件，两者都应该依赖于抽象)</li>
</ol>
</blockquote>
<ul>
<li>变量不可以持有具体类的引用<ul>
<li>不要让类派生自具体类</li>
<li>不要覆盖基类中已实现的方法</li>
</ul>
</li>
</ul>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><blockquote>
<p>定义了算法族，分别封装起来，让它们之间可以互相替换，让算法的变化独立于使用算法的客户 </p>
</blockquote>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><blockquote>
<p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新</p>
</blockquote>
<h4 id="装饰这模式"><a href="#装饰这模式" class="headerlink" title="装饰这模式"></a>装饰这模式</h4><blockquote>
<p>动态地将责任附加到对象上。若要拓展功能，装饰着提供了比继承更有弹性的替代方案</p>
</blockquote>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul>
<li>方法工厂</li>
</ul>
<blockquote>
<p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类  </p>
</blockquote>
<ul>
<li>抽象工厂</li>
</ul>
<blockquote>
<p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类  </p>
</blockquote>
<h4 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h4><blockquote>
<p>确保一个类只有一个实例，并提供一个全局访问点</p>
</blockquote>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote>
<p>“请求”封装成对象，以便使用不同的请求，列队或者日志来参数化其他对象。命令模式也支持可撤销的操作</p>
</blockquote>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类型可以合作无间。</p>
</blockquote>
<ul>
<li>对象适配器</li>
<li>类适配器(需要多重继承，java不支持)</li>
</ul>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><blockquote>
<p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
</blockquote>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><blockquote>
<p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤</p>
</blockquote>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</p>
</blockquote>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><blockquote>
<p>允许你将对象组合成树形结构来表现”整体&#x2F;部分”层次结构。组合能让客户以一致的方式处理对象以及对象组合</p>
</blockquote>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><blockquote>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了类。策略模式和状态模式是双胞胎，在出生时才分开</p>
</blockquote>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote>
<p>为另一个对象提供一个替身或占位符以控制对这个对象的访问，远程代理，虚拟代理,动态代理</p>
</blockquote>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote>
<p>把事物抽象和其具体行为、具体特征分离开来，使它们可以各自独立的变化 </p>
</blockquote>
<ul>
<li>使实现解耦，让它和界面之间不再永久绑定<ul>
<li>抽象和实现可以独立拓展，不会影响对方</li>
<li>对于“具体的抽象类”所做的改变，不会影响到客户。</li>
<li>增加复杂度</li>
</ul>
</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><blockquote>
<p>封装一个产品的构造过程，并允许按步骤构造。</p>
</blockquote>
<ul>
<li>将一个复杂对象的创建过程封装起来<ul>
<li>允许对象通过多个步骤来创建，并且可以改变过程</li>
<li>向客户隐藏产品内部的表现</li>
<li>产品的实现可以被替换，因为客户只看到一个抽象的接口</li>
</ul>
</li>
</ul>
<h4 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h4><blockquote>
<p>让一个以上的对象有机会能够处理某个请求的。</p>
</blockquote>
<ul>
<li>将请求的发送者和接受者解耦<ul>
<li>可以简化对象，因为它不需要知道链的结构。</li>
<li>通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任</li>
</ul>
</li>
</ul>
<h4 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h4><blockquote>
<p>让某个类的实例能够用来提供许多“虚拟实例”。</p>
</blockquote>
<ul>
<li>减少运行时对象实例的个数，节省内存<ul>
<li>将许多“虚拟”对象的状态集中管理</li>
</ul>
</li>
</ul>
<h4 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器(Interpreter)"></a>解释器(Interpreter)</h4><blockquote>
<p>未语言创建解释器</p>
</blockquote>
<ul>
<li>将每一种语法规则表示成一个类，方便于实现语言<ul>
<li>因为语法由许多类组成，所以可以轻易改变或拓展此语言</li>
<li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为</li>
</ul>
</li>
</ul>
<h4 id="中介者-Mediator"><a href="#中介者-Mediator" class="headerlink" title="中介者(Mediator)"></a>中介者(Mediator)</h4><blockquote>
<p>集中相关对象之间复杂的沟通和控制方式</p>
</blockquote>
<ul>
<li>将对象彼此解耦，增加对象的复用性<ul>
<li>集中控制逻辑，简化系统维护</li>
<li>让对象之间所传递的信息变得简单而且大幅减少</li>
</ul>
</li>
</ul>
<h4 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h4><blockquote>
<p>让对象返回之前的状态</p>
</blockquote>
<ul>
<li>将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚<ul>
<li>保持关键对象的数据封装</li>
<li>提供了容易实现的恢复能力</li>
</ul>
</li>
</ul>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><blockquote>
<p>创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
</blockquote>
<ul>
<li>对客户隐藏创建新实例的复杂性<ul>
<li>提供让客户能够产生未知类型对象的选项</li>
</ul>
</li>
</ul>
<h4 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h4><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<ul>
<li>允许对组合结构加入新的操作，而无需改变结构本身<ul>
<li>想要加入新的操作，相对容易</li>
<li>访问者所进行的操作，其代码是集中在一起的</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_5?ie=UTF8&qid=1478679780&sr=8-5&keywords=%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Head First</a><br><a target="_blank" rel="noopener" href="https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80-Erich-Gamma/dp/B001130JN8/ref=sr_1_1?ie=UTF8&qid=1478679820&sr=8-1&keywords=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式:可复用面向对象软件的基础</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/06/11/Little-stories-about-an-Android-application-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/11/Little-stories-about-an-Android-application-architecture/" class="post-title-link" itemprop="url">Little stories about an Android application architecture</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-06-11 15:59:27" itemprop="dateCreated datePublished" datetime="2016-06-11T15:59:27+08:00">2016-06-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://roroche.github.io/AndroidStarter/">原文</a></p>
<p>写这篇文章的目的是为了描述我建议的<code>Android app</code>架构。我一步步的通过下面的原因来选择不同的组件。</p>
<p>模板应用的目的很简单：它是<code>master/detail</code>结构，用来展示指定用户的<code>Github</code>仓库。虽然它简单，但它集合了一些通用的东西：</p>
<ul>
<li>使用<code>REST</code>API  <ul>
<li>本地数据存储</li>
<li>本地数据加载</li>
<li>架构逻辑层以及页面导航</li>
</ul>
</li>
</ul>
<p>让我们来看看这背后都有什么!</p>
<h3 id="Consuming-REST-API"><a href="#Consuming-REST-API" class="headerlink" title="Consuming REST API"></a>Consuming REST API</h3><blockquote>
<p>REST Representational State Transfer表述性状态传递</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">Retrofit</a>是开发者必备的知名网络库<br>我将解释为何我认为它是必备的库：  </p>
<ul>
<li>类型安全</li>
<li>接口可读性好，采用注解<code>API</code>地址</li>
<li>对如何工作采用完全抽象层</li>
<li>支持多部分请求体(上传文件)</li>
<li>使用注解直接管理头部信息</li>
<li>能够使用多种序列化类型(<code>JSON, XML, protobuf, etc</code>)的转换器</li>
<li>能够添加全局的请求拦截器</li>
<li>方便的进行<code>MOCK</code>测试</li>
</ul>
<p>使用时仅需在<code>build.gradle</code>文件中添加</p>
<p>&lt;!–code￼0–&gt;
</p>
<p>然后我能够声明<code>GitHubService</code>接口和我们需要使用这个接口的方法</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>下一步通过<code>RestAdapter</code>去实现这个接口</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>我使用<a target="_blank" rel="noopener" href="https://github.com/novoda/merlin">Merlin</a>。它能够观察网络的连接状态以及改变。它提供流畅<code>API</code>，设置简单。</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>调用</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>来检查网络是否可用。</p>
<h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><p>现在我们已经能够从服务器拿到数据了，我们需要将这些数据转换成<code>POJO</code>对象。通常的格式是<code>JSON</code>,我们使用<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a>来作为转换器。</p>
<p>当然，我将会说明一下为什么我选择<code>Jackson</code>。首先，我很满意它流畅的注解<code>API</code>。能够获取或存储那些没有通过<code>@JsonProperty</code>注解声明的属性</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>与<code>Retrofit</code>组合</p>
<p><a target="_blank" rel="noopener" href="https://github.com/square/retrofit/tree/master/retrofit-converters/jackson.">https:&#x2F;&#x2F;github.com&#x2F;square&#x2F;retrofit&#x2F;tree&#x2F;master&#x2F;retrofit-converters&#x2F;jackson.</a></p>
<p>&lt;!–code￼6–&gt;
</p>
<p>然后我们将其设置到我们之前的<code>RestAdapter</code></p>
<p>&lt;!–code￼7–&gt;
</p>
<p>福利
我通常使用<a target="_blank" rel="noopener" href="http://www.jsonschema2pojo.org/">jsonchema2pojo</a>  </p>
<blockquote>
<p>Generate Plain Old Java Objects from JSON or JSON-Schema.</p>
</blockquote>
<p>也可以使用<a target="_blank" rel="noopener" href="https://github.com/square/moshi">moshi</a>或者<a target="_blank" rel="noopener" href="https://github.com/bluelinelabs/LoganSquare">LoganSquare</a>  </p>
<h4 id="组件之间的通讯和数据传递"><a href="#组件之间的通讯和数据传递" class="headerlink" title="组件之间的通讯和数据传递"></a>组件之间的通讯和数据传递</h4><p>通常的做法是使用事件总线</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://square.github.io/otto/">Otto</a>  </li>
<li><a target="_blank" rel="noopener" href="http://greenrobot.github.io/EventBus/">EventBus</a> </li>
<li><a target="_blank" rel="noopener" href="https://github.com/beworker/tinybus">TinyBus</a></li>
</ul>
<blockquote>
<p>Now can using RxJava to replace above all  </p>
</blockquote>
<h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><blockquote>
<p>RxAndroid thread</p>
</blockquote>
<h4 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h4><p>多线程和并发是开发者经常要考虑的问题。我罗列出一些不能再主线程操作的任务</p>
<ul>
<li>调用远程API</li>
<li>数据库CURD操作</li>
<li>读取本地文件</li>
</ul>
<p>建议采取:</p>
<ul>
<li>使用<code>Service</code></li>
<li>设置<code>ServiceHelper</code>来进行网络请求</li>
<li>使用专门的类来处理查询操作</li>
</ul>
<p>但需要注意的是<code>Service</code>是运行在主线程中，因此可以使用<code>IntentService</code>或者使用<a target="_blank" rel="noopener" href="https://github.com/yigit/android-priority-jobqueue">Android Priority Job Queue</a>或者是官方的<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/app/job/JobScheduler.html">JobScheduler</a></p>
<h4 id="Job-Manager-android-priority-jobqueue"><a href="#Job-Manager-android-priority-jobqueue" class="headerlink" title="Job Manager(android-priority-jobqueue)"></a>Job Manager(android-priority-jobqueue)</h4><h5 id="Job-Manager-Configuration"><a href="#Job-Manager-Configuration" class="headerlink" title="Job Manager Configuration"></a>Job Manager Configuration</h5><p>&lt;!–code￼8–&gt;
</p>
<h5 id="Job-Configuration"><a href="#Job-Configuration" class="headerlink" title="Job Configuration"></a>Job Configuration</h5><p>我们可以给一个任务设置一些有用的参数，例如</p>
<ul>
<li>它的优先级</li>
<li>它是否需要网络</li>
<li>如果不执行，是否需要持久化</li>
<li>延时运行</li>
<li>重试机制</li>
</ul>
<p>这个库的持久化引擎非常强大。例如，网络不可用时，任务会被持久化到设备上。一旦网络可用<code>JobManager</code>获取持久化的任务并执行它们</p>
<p>&lt;!–code￼9–&gt;
</p>
<ul>
<li><p>枚举描述了我需要的优先级</p>
<ul>
<li>提供两个构造函数</li>
<li>异常处理</li>
<li>默认重试次数</li>
</ul>
<p>有三个方法被实现</p>
<ul>
<li><code>execute</code>: 执行特定的代码</li>
<li><code>postEventQueryFinished </code>: 通知任务结果</li>
<li><code>postEventQueryFinishedNoNetwork </code>: 通知网络不可用</li>
</ul>
<p>后两个通常基于总线</p>
<p>下面是我定义的抽象事件</p>
<p>&lt;!–code￼10–&gt;
</p>
<ul>
<li>查询刚完成</li>
<li>终端状态</li>
<li>异常处理</li>
</ul>
<p>下面是我的查询用户仓库的代码</p>
<p>&lt;!–code￼11–&gt;</p>
</li>
</ul>
<p>现在，通过<code>QueryFactor</code>这个简单的代理类来进行请求</p>
<p>&lt;!–code￼12–&gt;
</p>
<p><code>Service</code>处理如下声明的查询:</p>
<p>&lt;!–code￼13–&gt;
</p>
<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><h4 id="ORM-方式"><a href="#ORM-方式" class="headerlink" title="ORM 方式"></a>ORM 方式</h4><p>对象关系映射是软件开发中经常使用的技术</p>
<h4 id="OrmLite"><a href="#OrmLite" class="headerlink" title="OrmLite"></a><a target="_blank" rel="noopener" href="http://ormlite.com/sqlite_java_android_orm.shtml">OrmLite</a></h4><p>第一步设置要被映射的<code>POJO</code>
我创建抽象类来匹配<code>_id</code>列</p>
<p>&lt;!–code￼14–&gt;
</p>
<p>现在创建一个<code>POJO</code>类</p>
<p>&lt;!–code￼15–&gt;
</p>
<p>我们来看一下DAO。这个设计目的在于通过抽象的接口来访问具体的数据。</p>
<p><code>OrmLite</code>提供了<code>Dao</code>接口以及其实现<code>BaseDaoImpl</code>。CURD所需的操作都具备。</p>
<p>然而，这些都是同步执行的。使用<code>RxJava</code>来异步执行这些操作。</p>
<p>因此我使用<code>RxJava</code>重写了所有的方法
我创建了如下接口</p>
<p>&lt;!–code￼16–&gt;
</p>
<p>所有的方法名以”rx”为前缀。返回一个特定类型的<code>Observable</code>对象</p>
<p>&lt;!–code￼17–&gt;
</p>
<p>使用<code>long</code>作为ID类型</p>
<p>&lt;!–code￼18–&gt;
</p>
<p>抽象类</p>
<p>&lt;!–code￼19–&gt;
</p>
<p><code>DAORepo</code>变成</p>
<p>&lt;!–code￼20–&gt;
</p>
<p><code>ORMLite</code>提供<code>SQLiteOpenHelper</code>的抽象子类<code>OrmLiteSQLiteOpenHelper</code>。</p>
<p>&lt;!–code￼21–&gt;
</p>
<p><code>ORMLite</code>提供<code>TableUtils</code>，其可以根据映射的类文件创建或者删除表</p>
<p>现在，我们需要一个<code>DatabaseHelperAndroidStarter</code>来处理数据</p>
<p>&lt;!–code￼22–&gt;
</p>
<p>我们能通过下面的方式获得一个<code>DAORepo</code>实例</p>
<p>&lt;!–code￼23–&gt;
</p>
<p>在<code>Fragment</code>中，通过以下方式获取仓库</p>
<p>&lt;!–code￼24–&gt;
</p>
<p>但仍然有个问题：如何从网络上获取一个仓库并把它解析然后存储到本地?</p>
<p>我的目标是使用<code>DTORepo</code>来与网络通讯,<code>RepoEntity</code>映射到数据库。它们有相同名字的相同的字段。因此我需要一个工具用来把DTO转换成实体。这时候，我们会用到<a target="_blank" rel="noopener" href="https://github.com/txusballesteros/android-transformer">Android Transformer</a></p>
<p>它提供两个主要的注解</p>
<ul>
<li><code>@Mappable</code>来代表要映射的类<ul>
<li><code>@Mapped</code>代表要映射的成员</li>
</ul>
</li>
</ul>
<p>因此，<code>RepoEntity</code>变成:</p>
<p>&lt;!–code￼25–&gt;
</p>
<p>现在我们能通过以下方式将DTO转换成实体</p>
<p>&lt;!–code￼26–&gt;
</p>
<p><a target="_blank" rel="noopener" href="https://github.com/stephanenicolas/ormlite-android-gradle-plugin">ormgap</a>插件</p>
<h4 id="ContentProvider方式"><a href="#ContentProvider方式" class="headerlink" title="ContentProvider方式"></a>ContentProvider方式</h4><p><code>ContentProvider</code>和<code>Cursor</code>及其派生配合使用异常强大。  </p>
<p>使用<a target="_blank" rel="noopener" href="https://github.com/TimotheeJeannin/ProviGen">ProviGen</a>有以下优势：</p>
<ul>
<li>声明<code>ContentProvider</code>相关类方便<ul>
<li>使用<code>ProviGenProvider</code>，其是<code>ContentProvider</code>的一个子类</li>
<li>提供<code>SQLiteOpenHelper</code>默认实现</li>
<li>能够自定义<code>SQLiteOpenHelper</code>的实现</li>
<li><code>TableBuilder</code>能够使用流畅的API创建<code>SQL</code>表</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/chalup/microorm">MicroOrm</a></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入优点：</p>
<ul>
<li><p>便于阅读</p>
<ul>
<li>便于维护</li>
<li>便于测试</li>
</ul>
<p>…</p>
</li>
</ul>
<h3 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h3><p><a target="_blank" rel="noopener" href="http://hannesdorfmann.com/mosby/">文章</a><br>你能在这了解到MVP基础，VIEW状态和Loading-Content-Error</p>
<p>另一个有用的工具是<a target="_blank" rel="noopener" href="http://developer.android.com/tools/data-binding/guide.html">DataBinding</a>。它能使<code>View</code>和<code>Model</code>紧密耦合，双向绑定。</p>
<p>使用<code>Mosby</code>来解释MVP</p>
<p>首先设计我们要展示内容的模型类</p>
<p>&lt;!–code￼27–&gt;
</p>
<p>现在我们定义了对应的<code>View</code>接口</p>
<p>&lt;!–code￼28–&gt;
</p>
<p>下一步是定义<code>Presenter</code></p>
<p>&lt;!–code￼29–&gt;
</p>
<p>主要代码放在<code>rxGetRepo</code>方法中。它从数据库加载数据,然后刷新UI</p>
<p>我们来看一下<code>FragmentRepoDetail</code></p>
<p>&lt;!–code￼30–&gt;
</p>
<p>当中的一些注解会在下一节中解释</p>
<p>我们来看一下对应的布局</p>
<p>&lt;!–code￼31–&gt;
</p>
<p>多亏了MVP架构，我们收获良多
 * 独立的类来加载和展示对应的数据：<code>Presenter</code>
 * 要展示的数据: <code>Model</code>
 * 展示的方式: <code>View</code></p>
<h3 id="写更轻量的类"><a href="#写更轻量的类" class="headerlink" title="写更轻量的类"></a>写更轻量的类</h3><h4 id="注解和注解处理器的好处"><a href="#注解和注解处理器的好处" class="headerlink" title="注解和注解处理器的好处"></a>注解和注解处理器的好处</h4><p><code>android-apt</code>是<code>Android</code> 开发的一大进步。</p>
<p>它允许开发者在<code>gradle</code>文件中配置编译时的注解处理。很多库用它来生成模板代码。</p>
<h4 id="Butter-Knife"><a href="#Butter-Knife" class="headerlink" title="Butter Knife"></a>Butter Knife</h4><h4 id="FragmentArgs"><a href="#FragmentArgs" class="headerlink" title="FragmentArgs"></a>FragmentArgs</h4><h4 id="IntentBuilder"><a href="#IntentBuilder" class="headerlink" title="IntentBuilder"></a>IntentBuilder</h4><h4 id="Icepick"><a href="#Icepick" class="headerlink" title="Icepick"></a>Icepick</h4><h4 id="OnActivityResult"><a href="#OnActivityResult" class="headerlink" title="OnActivityResult"></a>OnActivityResult</h4><h4 id="Project-Lombok"><a href="#Project-Lombok" class="headerlink" title="Project Lombok"></a>Project Lombok</h4><h4 id="Switcher"><a href="#Switcher" class="headerlink" title="Switcher"></a>Switcher</h4><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p><a target="_blank" rel="noopener" href="https://github.com/ignaciotcrespo/frutilla">frutilla</a>  </p>
<h4 id="Fluent-assertions"><a href="#Fluent-assertions" class="headerlink" title="Fluent assertions"></a>Fluent assertions</h4><ul>
<li>truth<ul>
<li>AssertJ</li>
<li>AssertJ Android</li>
</ul>
</li>
</ul>
<h4 id="Mocking"><a href="#Mocking" class="headerlink" title="Mocking"></a>Mocking</h4><h4 id="UI-testing"><a href="#UI-testing" class="headerlink" title="UI testing"></a>UI testing</h4><h4 id="Code-coverage"><a href="#Code-coverage" class="headerlink" title="Code coverage"></a>Code coverage</h4><p>&lt;!–code￼32–&gt;
</p>
<h3 id="Code-quality"><a href="#Code-quality" class="headerlink" title="Code quality"></a>Code quality</h3><ul>
<li><a target="_blank" rel="noopener" href="http://checkstyle.sourceforge.net/">CheckStyle</a><ul>
<li><a target="_blank" rel="noopener" href="http://findbugs.sourceforge.net/">FindBugs</a></li>
<li><a target="_blank" rel="noopener" href="http://pmd.github.io/">PMD</a></li>
<li><a target="_blank" rel="noopener" href="http://tools.android.com/tips/lint">Android Lint</a></li>
</ul>
</li>
</ul>
<h3 id="Relevant-libraries"><a href="#Relevant-libraries" class="headerlink" title="Relevant libraries"></a>Relevant libraries</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2016/06/04/analysis-recyclerview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/04/analysis-recyclerview/" class="post-title-link" itemprop="url">recyclerview-structure</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2016-06-04 16:51:53 / Modified: 16:58:30" itemprop="dateCreated datePublished" datetime="2016-06-04T16:51:53+08:00">2016-06-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本系列主要分析<code>RecyclerView</code>的源码。本文主要分析<code>RecyclerView</code>的源码结构，以及其各机构的作用。首先来看一下<code>RecyclerView</code>的源码结构:</p>
<p><img data-src="/./RecyclerView.jpg"></p>
<p>从图上可以看出<code>RecyclerView</code>依赖了很多别的类。接下来我们首先介绍各个类的作用。</p>
<ul>
<li>RecyclerViewDataObserver 数据观察器</li>
<li>Recycler View循环复用系统，核心部件</li>
<li>SavedState RecyclerView状态</li>
<li>AdapterHelper 适配器更新</li>
<li>ChildHelper 管理子View</li>
<li>ViewInfoStore 存储子VIEW的动画信息</li>
<li>Adapter 数据适配器</li>
<li>LayoutManager 负责子VIEW的布局，核心部件</li>
<li>ItemAnimator Item动画</li>
<li>ViewFlinger 快速滑动管理</li>
<li>NestedScrollingChildHelper 管理子VIEW嵌套滑动</li>
</ul>
<h3 id="创建布局管理器"><a href="#创建布局管理器" class="headerlink" title="创建布局管理器"></a>创建布局管理器</h3><p>&lt;!–code￼0–&gt;
</p>
<p>如果在布局文件里面设置了布局管理器的类型，那么这里会通过反射的方式实例化出对应的布局管理器。最后将实例化出的布局管理器设置到当前的<code>RecyclerView</code></p>
<h3 id="设置布局管理器"><a href="#设置布局管理器" class="headerlink" title="设置布局管理器"></a>设置布局管理器</h3><p>&lt;!–code￼1–&gt;
</p>
<p>设置布局管理器之前会先清空所有之前的缓存VIEW。最后通知VIEW刷新</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>onMeasure这个回调方法用于测量<code>VIEW</code>的大小</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>从上述代码可以看出，</p>
<ul>
<li>如果布局是空的，那么<code>RecyclerView</code>会创建调用<code>defaultOnMeasure</code>方法</li>
</ul>
<p>&lt;!–code￼3–&gt;
</p>
<p>默认测量是布局管理器根据指定的宽，高规格，算出宽高。</p>
<ul>
<li>如果是自动布局，如果宽高都是明确指定的，那么跳过测量。否则，如果</li>
<li>目前是初始阶段，那么调用<code>dispatchLayoutStep1</code></li>
</ul>
<p>&lt;!–code￼4–&gt;
</p>
<ul>
<li>第二步，用老的尺寸规格来预布局，然后调用<code>dispatchLayoutStep2</code></li>
</ul>
<p>&lt;!–code￼5–&gt;
</p>
<ul>
<li>这之后我们就能够获取子<code>VIEW</code>的宽高了。如果<code>RecyclerView</code>没有明确的宽高，那么我们需要再次测量，然后重复上述步骤。</li>
<li>如果不是自动布局，如果是固定大小，那么直接用现有规格测量。否则首先进行一些动画前置操作，最后依然由布局管理器来测量。</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p><code>onLayout</code>是确定位置时的回调方法。</p>
<p>&lt;!–code￼6–&gt;
</p>
<p><code>dispatchLayout</code>  </p>
<p>&lt;!–code￼7–&gt;
</p>
<ul>
<li>如果是初始状态，调用<code>dispatchLayoutStep1</code>，测量，调用<code>dispatchLayoutStep2</code>。如果高度或宽度发生变化，测量，调用<code>dispatchLayoutStep2</code>。其他情况制作测量。最后统一调用<code>dispatchLayoutStep3</code>主要处理动画。</li>
</ul>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p><code>onDraw</code>是绘制时的回调  </p>
<p>&lt;!–code￼8–&gt;
</p>
<p>主要对<code>ItemDecoration</code>的绘制</p>
<p>至此，<code>RecyclerView</code>的主要回调方法已经简单介绍完毕。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Binea</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
