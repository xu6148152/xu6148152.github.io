<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xu6148152.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://xu6148152.github.io/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale">
<meta property="article:author" content="Binea">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://xu6148152.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"default","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Binea</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2022/06/08/fresco-memory-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/08/fresco-memory-cache/" class="post-title-link" itemprop="url">fresco之内存bitmap缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-08 11:52:42 / Modified: 17:14:15" itemprop="dateCreated datePublished" datetime="2022-06-08T11:52:42+08:00">2022-06-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近因为项目优化需要，重温<code>Fresco</code>的内存缓存机制。做了一些简单分析。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img data-src="/./fresco_memory_cache_class.jpg"></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img data-src="/./fresco_memory_cache_flow.jpg"></p>
<p>&lt;!–more–&gt;
</p>
<p>虚线框出来的部分对应缓存资源和获取资源，两个流程里面都会触发移除无用资源，移除的条件是无用资源的数目大于设定(总共-已使用(cacheEntriesCount - exclusiveCacheEntriesCount))，或者是无用资源的体积大小超过了设定(总共-已使用(cacheEntries-exclusiveCache))，每次触发资源释放(releaseClientReference)的时候都会将没有被引用的资源放到无用缓存中。上述流程中，cache触发了缓存，但是要先检查是否满足条件，否则就跳过了，尝试移除无用资源，因此这里的内存缓存可能失效。Fresco能够在View detach的时候自动触发资源回收</p>
<h3 id="内存释放时序图"><a href="#内存释放时序图" class="headerlink" title="内存释放时序图"></a>内存释放时序图</h3><p><img data-src="/./fresco_memory_cache_sequence.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2019/01/20/%E4%BD%BF%E7%94%A8NDK%E7%BC%96%E8%AF%91FFmpeg4-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/20/%E4%BD%BF%E7%94%A8NDK%E7%BC%96%E8%AF%91FFmpeg4-1/" class="post-title-link" itemprop="url">使用NDK编译FFmpeg4.1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-20 19:45:43" itemprop="dateCreated datePublished" datetime="2019-01-20T19:45:43+08:00">2019-01-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>操作系统: Mac OS 10.13.6<br>FFMpeg版本: 4.1<br>NDK版本: android-ndk-r18b
编译器: clang</p>
<h3 id="构建ndk编译链"><a href="#构建ndk编译链" class="headerlink" title="构建ndk编译链"></a>构建ndk编译链</h3><p>执行<code>ndk</code>自带的脚本构建编译链,会生成编译环境</p>
<p>&lt;!–code￼0–&gt;
</p>
<h3 id="构建ffmpeg编译环境"><a href="#构建ffmpeg编译环境" class="headerlink" title="构建ffmpeg编译环境"></a>构建ffmpeg编译环境</h3><p>修改ffmpeg项目根目录下<code>configure</code>文件将这几个环境变量替换成如下</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>准备<code>ffmpeg-toolchain-env.sh</code>脚本,如下</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>这个脚本应该是通用脚本，网上很多，但是有些脚本提供是错的。<code>-android</code>写成了<code>-mandroid</code>这里需要注意</p>
<p>执行以下命令</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>然后ffmpeg就开始编译了。编译成功后会生成如下文件件</p>
<p><img data-src="/./ffmpeg_built_output.webp" alt="ffmpeg_output"></p>
<h3 id="编译过程中可能遇到的错误"><a href="#编译过程中可能遇到的错误" class="headerlink" title="编译过程中可能遇到的错误"></a>编译过程中可能遇到的错误</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>&lt;!–code￼4–&gt;
</p>
<p>解决: 解决：将libavcodec&#x2F;aaccoder.c文件B0变量替换成b0</p>
<h4 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h4><p>&lt;!–code￼5–&gt;
</p>
<p>解决: 将libavcodec&#x2F;hevc_mvs.c文件的变量B0改成b0，xB0改成xb0，yB0改成yb0</p>
<h4 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h4><p>&lt;!–code￼6–&gt;
</p>
<p>解决：将libavcodec&#x2F;opus_pvq.c文件的变量B0改成b0</p>
<h3 id="打包成ffmpeg-so"><a href="#打包成ffmpeg-so" class="headerlink" title="打包成ffmpeg.so"></a>打包成ffmpeg.so</h3><p>上面我们编译出了libXXX.a或者libXXX.so库，当然直接拷贝到android工程引用是一种方式，还有一种就是将静态库打成一个动态库，这样android程序启动的时候只要加载一个动态库即可，理论上效率更高。同样的，先加载环境变量、打包、压缩优化。</p>
<p>&lt;!–code￼7–&gt;
</p>
<p>会生成一个ffmpeg.so</p>
<p><img data-src="/./ffmpeg_built_package.webp"></p>
<p>对so文件进行裁剪压缩以下</p>
<p>&lt;!–code￼8–&gt;
</p>
<p>这样打包出来的so库大小
<img data-src="/./ffmpeg_built_trim.png"></p>
<p>至此ffmpg的编译已经完成了。</p>
<h3 id="Android-Studio使用ffmpeg-so"><a href="#Android-Studio使用ffmpeg-so" class="headerlink" title="Android Studio使用ffmpeg.so"></a>Android Studio使用ffmpeg.so</h3><p>在<code>main</code>下面建立<code>cpp</code>或者<code>jni</code>然后将<code>libffmpeg.so</code>拷到如下目录</p>
<p><img data-src="/./as_ffmpeg_src.png"></p>
<p>在<code>cpp</code>或者<code>jni</code>根目录下创建<code>CMakeLists.txt</code>文件，在<code>build.gradle</code>文件中加入</p>
<p>&lt;!–code￼9–&gt;
</p>
<p>在<code>CMakeFileLists</code>脚本中加入</p>
<p>&lt;!–code￼10–&gt;
</p>
<p>在<code>kotlin</code>中载入动态库</p>
<p>&lt;!–code￼11–&gt;
</p>
<p>然后build,这个时候去看<code>apk</code></p>
<p><img data-src="/./ffmpeg_apk_pack.png"></p>
<p>至此<code>ffmpeg.so</code>成功打包到了apk当中。</p>
<p>打包的过程中可能会报找不到<code>so</code>文件,这个时候需要检查一下<code>so</code>文件与<code>eabi</code>是否与<code>gradle</code>的配置一致。<code>so</code>文件的目录不能单纯的使用<code>armeabi</code>，这样会导致<code>so</code>无法打包到<code>apk</code>里</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2018/04/05/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/05/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Zookeeper源码分析之选举机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-05 16:19:17" itemprop="dateCreated datePublished" datetime="2018-04-05T16:19:17+08:00">2018-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Zookeeper</code>提供了三种选举方式</p>
<ul>
<li>AuthFastLeaderElection</li>
<li>带认证的AuthFastLeaderElection</li>
<li>FastLeaderElection</li>
</ul>
<h3 id="选择机制"><a href="#选择机制" class="headerlink" title="选择机制"></a>选择机制</h3><p>选举状态</p>
<p>&lt;!–code￼0–&gt;
</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>如果当前节点的状态是正在寻找<code>leader</code>节点，那么创建当前投票</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>创建选举算法，默认是采用<code>FastLeaderElection</code>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QuorumPeerConfig.java</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">electionAlg</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>创建<code>QuorumCnxManager</code>管理器，创建<code>FastLeaderElection</code>并开始选举</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>启动<code>ws</code>和<code>wr</code>线程</p>
<p><code>WorkerSender</code>发送队列</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>从队列中读取数据，然后调用<code>process</code>处理。使用<code>ByteBuffer</code>封装要发送的数据</p>
<p>&lt;!–code￼6–&gt;
</p>
<p>如果发送节点和接收节点相同，那么直接进入接受节点.否则放入发送队列。然后连接目标节点</p>
<p>&lt;!–code￼7–&gt;
</p>
<p>当前节点状态是<code>LOOKING</code>时，寻找<code>leader</code>节点</p>
<p>&lt;!–code￼8–&gt;
</p>
<p>给自己投票，将投票信息发送给其他节点。循环上述操作，直到选出结果。</p>
<ul>
<li>如果没有收到消息<ul>
<li>确认所有的消息都已经接收完，则对外发送消息</li>
<li>尝试连接其他服务器</li>
</ul>
</li>
<li>接收的消息来自集群服务器  <ul>
<li>如果选举轮次大于当前轮次，则更新当前选票信息并通知其他服务器</li>
<li>检查是否已经有选举结果</li>
</ul>
</li>
<li>同一轮选举<ul>
<li>判断是否已经有选举结果</li>
</ul>
</li>
</ul>
<p>选举流程简述:</p>
<p>假设有5台服务器，编号分别为0,1,2,3,4。选举过程如下</p>
<ul>
<li>服务器0给自己投票，然后发送投票信息，进入<code>LOADING</code></li>
<li>服务器1给自己投票，然后与0交换投票结果。1的编号大于0,1胜出，但参与投票数没有大于半数。继续等待</li>
<li>服务器2给自己投票，然后与0,1交换投票结果，2胜出，成为<code>leader</code></li>
<li>服务器3给自己投票，与0,1,2交换结果,3胜出，但参与投票数没有超过半数，等待</li>
<li>服务器4给自己投票，与0,1,2,3,4交换结果，4胜出，成为<code>leader</code></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2018/04/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAZooKeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAZooKeeper/" class="post-title-link" itemprop="url">深入浅出ZooKeeper</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-01 16:29:43" itemprop="dateCreated datePublished" datetime="2018-04-01T16:29:43+08:00">2018-04-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Zookeeper</code>是分布式调度服务。在分布式系统当中，当集群中的部分节点出现故障，那么需要通知其他节点。<code>Zookeeper</code>主要就是用来解决这个问题</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以上将编写<code>Zookeeper</code>客户端程序，来展示其是如何管理集群中的节点</p>
<h4 id="组和成员"><a href="#组和成员" class="headerlink" title="组和成员"></a>组和成员</h4><p><code>Zookeeper</code>可以看成是一个高可用的文件系统，但它没有文件和文件夹的概念，其是一个树状结构。它的基本单元是<code>znode</code>，其主要用来存储数据。</p>
<p><img data-src="/./znode.jpeg"></p>
<h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><p>&lt;!–code￼0–&gt;
</p>
<p>创建一个<code>CreateGroup</code>对象，然后调用<code>connect</code>方法,通过<code>ZooKeeper</code>的<code>api</code>与<code>ZooKeeper</code>服务器连接。指定三个参数，服务端主机名以及端口，连接超时时间，<code>Watcher</code>接口的实例，<code>Watcher</code>主要是负责接收<code>ZooKeeper</code>数据变化时产生的事件回调。</p>
<p>创建之后使用<code>CountDownLatch</code>，让当前线程等待，直到<code>ZooKeeper</code>准备就绪。当<code>ZooKeeper</code>准备就绪时，<code>Watcher</code>接口的方法<code>process</code>会回调连接成功事件，然后<code>CountDownLatch</code>释放。</p>
<p>连接成功之后创建<code>znode</code>组，可以指定<code>path</code>,<code>内容</code>和<code>ACL</code>。<code>znode</code>的分为<code>ephemeral</code>和<code>persistent</code>两种，使用<code>ephemeral</code>时，创建<code>znode</code>的客户端的会话结束或者客户端与服务端断开时，该<code>znode</code>会被自动删除。而<code>persistent</code>的<code>znode</code>，除非是客户端主动删除，否则永远存在</p>
<h4 id="加入组"><a href="#加入组" class="headerlink" title="加入组"></a>加入组</h4><p>&lt;!–code￼1–&gt;
</p>
<p>加入组与创建组类似，都需要先连接<code>Zookeeper</code>服务器，然后创建<code>EPHEMERAL</code>类型的<code>znode</code>。这样当客户端断开时会自动删除该<code>znode</code></p>
<h4 id="成员列表"><a href="#成员列表" class="headerlink" title="成员列表"></a>成员列表</h4><p>&lt;!–code￼2–&gt;
</p>
<p>调用<code>Zookeeper</code>的<code>getChildren</code>方法来获取某个<code>path</code>下的节点，如果不存在节点，那么会抛出<code>NoNodeException</code></p>
<h3 id="Zookeeper服务模型"><a href="#Zookeeper服务模型" class="headerlink" title="Zookeeper服务模型"></a>Zookeeper服务模型</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p><code>Zookeeper</code>包含了一个树形的数据模型，那就是<code>znode</code>。一个<code>znode</code>中包含了存储的数据和<code>ACL</code>。<code>Zookeeper</code>的数据模型适合存储少量的数据，单个<code>znode</code>不能存储超过<code>1M</code>的数据</p>
<p>数据的访问具有原子性。意味着从<code>znode</code>中获取的数据永远都是完整的。不可能出现部分数据的情况。<code>znode</code>的路径必须是全路径，是简单的字符串，默认有个叫<code>zookeeper</code>的根节点，用来存储一些管理数据</p>
<h5 id="ephemeral-临时-znodes"><a href="#ephemeral-临时-znodes" class="headerlink" title="ephemeral(临时)znodes"></a>ephemeral(临时)znodes</h5><p><code>ephemeral</code>节点，当客户端的<code>session</code>结束了，该节点会被自动删除。而<code>persistent</code>节点创建之后就跟客户端没有关系了，需要客户端主动删除。<code>ephemeral</code>节点不会有子节点，其对所有客户端可见，但只绑定创建者客户端</p>
<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>创建<code>znode</code>时，会在名字后面增加一个数字。这就是每个节点的序号。例如</p>
<p>创建一个<code>znode</code>指定命名为<code>/a/b-</code>，那么最后创建完的名字是<code>/a/b-3</code>，再创建一个<code>/a/b-</code>的节点，那么最后的名字是<code>/a/b-5</code>。调用<code>create</code>方法的返回值是<code>znode</code>的真实名字。这些序号主要是用来排序的</p>
<h5 id="观察模式-Watches"><a href="#观察模式-Watches" class="headerlink" title="观察模式 Watches"></a>观察模式 Watches</h5><p>观察模式可以使客户端在某个节点发生变化时得到通知。例如，客户端对某个<code>znode</code>进行了<code>exist</code>操作，同时在<code>znode</code>上开启了观察模式，如果<code>znode</code>不存在，这个<code>exist</code>操作将返回<code>false</code>。之后如果客户端创建了这个<code>znode</code>，观察者模式将触发，并通知开启了观察者模式的客户端。观察者模式只能被触发一次，如果要持续对某个节点进行观察，那么需要持续对该节点开启观察者模式</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>| 操作       | 说明          | 
| ————- |:————-:| 
| create     | 创建znode |
| delete      | 删除znode      | 
| exists | 判断znode是否存在     |
| getACL, setACL | 获取znode访问控制列表 | 
| getChildren | 获取znode的子节点 | 
| getData, setData | 设置或获取znode关联节点的数据 | 
| sync | 同步客户端和服务端znode的状态 |</p>
<p>在调用<code>delete</code>和<code>setData</code>时，必须指定<code>znode</code>数据的版本号。<code>Zookeeper</code>支持将多个操作组合成一个操作单元</p>
<p><code>Zookeeper</code>支持同步和异步操作。</p>
<p>读操作会在<code>znode</code>上开启观察模式，并且写操作会触发观察模式。而写操作不会启动观察者模式</p>
<ul>
<li><code>exists</code>启动的观察模式，由<code>create</code>, <code>setData</code>, <code>delete</code>来触发</li>
<li><code>getData</code>启动的观察模式， 由<code>delete</code>, <code>setData</code>来触发，<code>create</code>不会触发</li>
<li><code>getChildren</code>启动的观察者模式，由子节点创建和删除，或者本节点被删除才会触发</li>
</ul>
<p><code>znode</code>被创建时，赋予了<code>ACL</code>。通过如下几种方式来鉴权</p>
<ul>
<li>digest: 用户名和密码</li>
<li>sast: 使用<code>Kerberos</code>鉴权</li>
<li>ip: 使用客户端<code>ip</code>鉴权</li>
</ul>
<p>&lt;!–code￼3–&gt;
</p>
<p><code>exist</code>不受<code>ACL</code>控制，所有的客户端均可操作</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>Zookeeper</code>服务可以在两种模式下运行。<code>standalone</code>模式下，可以运行一个单独的<code>Zookeeper</code>服务器。在生产环境中，会采用<code>replicated</code>模式安装在多台服务器上，组建<code>ensemble</code>集群。<code>Zookeeper</code>和它的副本组成高可用的集群，只要<code>ensemble</code>能够选举出主服务器，那么<code>Zookeeper</code>就不会中断。例如在一个5节点的<code>ensemble</code>中，能够容忍两个节点脱离集群，服务还是可用的。因为剩下的三个节点投票，可以产生超过集群半数的投票，来推选一台服务器。而6个节点的服务器，最多也只能容忍2个节点脱离集群，因为剩下的三个节点无法产生超过集群半数的投票。所以一般<code>ensemble</code>中节点的数量都是奇数。</p>
<p><code>Zookeeper</code>做的是保证每一次对<code>znode</code>树的修改，能够复制到<code>ensemble</code>集群中的大多数节点中。如果非主服务器脱离集群，那么剩下的服务器也能很快更新到最新的状态</p>
<p><code>Zookeeper</code>使用<code>Zab</code>协议。这个协议包括两个阶段
 * 领导选举:<br> <code>ensumble</code>集群选举出一个<code>leader</code>节点。其他节点为<code>follower</code>。当大多数<code>follower</code>与<code>leader</code>状态完成同步，那么这个阶段完成
 * 原子广播:<br> 所有的写入请求都会发送给<code>leader</code>,<code>leader</code>在广播给<code>follower</code>。当大多数<code>follower</code>完成了数据同步，<code>leader</code>才会更新提交。</p>
<p> 如果之前的<code>leader</code>回到集群，那么会被当做是一个<code>follower</code>。<code>leader</code>选举很快，大概200ms就能够产生结果，所以不会影响效率</p>
<p> <code>ensemble</code>的所有节点都会在更新内存中的<code>znode</code>树的副本之前，先将更新数据写入到硬盘上</p>
<h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><p><code>ensemble</code>集群中<code>follower</code>的<code>update</code>操作会滞后于<code>leader</code>操作。<code>Zookeeper</code>客户端的最佳实践是全部链接到<code>follower</code>上。然而客户端是有可能链接到<code>leader</code>上的，并且客户端控制不了这个选择，客户端也不知道连接到<code>follower</code>还是<code>leader</code>。一般的操作都是读直接从<code>follower</code>读取，写需要写入到<code>leader</code>。这跟数据库的读写分离类似</p>
<p><img data-src="/./consistency.jpeg"></p>
<p>每一个对<code>znode</code>树的更新操作，都会被赋予一个全局的唯一<code>ID</code>，我们称为<code>zxid</code>。更新操作的<code>ID</code>按照发生的时间顺序升序排序</p>
<p><code>Zookeeper</code>在数据一致性上实现了以下几方面:</p>
<ul>
<li><p>顺序一致性:<br>从客户端提交的更新操作都是按照先后循环排序的</p>
<ul>
<li>原子性
更新操作只有成功和失败</li>
<li>系统视图唯一性
无论客户端连接到哪个服务器，都将看见唯一的系统视图。客户端连接的服务器状态永远都是最新的</li>
<li>持久性
一旦操作成功，数据将被持久化到服务器上,并且不能撤销，所以服务器宕机重启，也不会影响数据</li>
<li>时效性
系统视图的状态更新的延迟时间是有一个上限的，最多不过几十秒。如果服务器的状态落后于其他服务器太多，<code>ZooKeeper</code>宁可关闭这个服务器上的服务，强制客户端去连接一个状态更新的服务器</li>
</ul>
<p>为了保证数据的一致性，那么客户端在读取数据的时候，需要先调用<code>sync</code>来同步状态</p>
<h4 id="会话Session"><a href="#会话Session" class="headerlink" title="会话Session"></a>会话Session</h4><p><code>Zookeeper</code>客户端中，配置了一个<code>ensemble</code>服务器列表。当启动时，首先尝试连接其中一个服务器，如果连接失败，那么会尝试连接下一个，直到成功或者全部失败</p>
<p>一旦连接成功，服务器就会为客户端创建一个会话（session）。session的过期时间由创建会话的客户端应用来设定，如果在这个时间期间，服务器没有收到客户端的任何请求，那么session将被视为过期，并且这个session不能被重新创建，而创建的ephemeral znode将随着session过期被删除掉。在会话长期存在的情况下，session的过期事件是比较少见的，但是应用程序如何处理好这个事件是很重要的。</p>
<p>在长时间的空闲情况下，客户端会不断的发送ping请求来保持session。ping请求的间隔被设置成足够短，以便能够及时发现服务器失败（由读操作的超时时长来设置），并且能够及时的在session过期前连接到其他服务器上。</p>
</li>
</ul>
<p>容错连接到其他服务器上，是由ZooKeeper客户端自动完成的。重要的是在连接到其他服务器上后，之前的session以及epemeral节点还保持可用状态。
在容错的过程中，应用将收到与服务断开连接和连接的通知。Watch模式的通知在断开链接时，是不会发送断开连接事件给客户端的，断开连接事件是在重新连接成功后发送给客户端的。如果在重新连接到其他节点时，应用尝试一个操作，这个操作是一定会失败的。对于这一点的处理，是一个ZooKeeper应用的重点。</p>
<h5 id="time"><a href="#time" class="headerlink" title="time"></a>time</h5><p>在ZooKeeper中有一些时间的参数。tick是ZooKeeper的基础时间单位，用来定义ensemble中服务器上运行的程序的时间表。其他时间相关的配置都是以tick为单位的，或者以tick的值为最大值或者最小值。例如，session的过期时间在2 ticks到20 ticks之间，那么你再设置时选择的session过期时间必须在2和20之间的一个数。</p>
<p>通常情况1 tick等于2秒。那么就是说session的过期时间的设置范围在4秒到40秒之间。在session过期时间的设置上有一些考虑。过期时间太短会造成加快物理失败的监测频率。在组成员关系的例子中，session的过期时间与从组中移除失败的成员花费的时间相等。如果设置过低的session过期时间，那么网络延迟就有可能造成非预期的session过期。这种情况下，就会出现在短时间内一台机器不断的离开组，然后又从新加入组中。</p>
<p>如果应用需要创建比较复杂的临时状态，那么就需要较长的session过期时间，因为重构花费的时间比较长。有一些情况下，需要在session的生命周期内重启，而且要保证重启完后session不过期（例如，应用维护和升级的情况）。服务器会给每一个session一个ID和密码，如果在连接创建时，ZooKeeper验证通过，那么session将被恢复使用（只要session没过期就行）。所以应用程序可以实现一个优雅的关机动作，在重启之前，将session的ID和密码存储在一个稳定的地方。重启之后，通过ID和密码恢复session。</p>
<p>在一些特殊的情况下，我们需要使用这个特性来使用比较长的session过期时间。大多数情况下，我们还是要考虑当出现非预期的异常失败时，如何处理session过期，或者仅需要优雅的关闭应用，在session过期前不用重启应用。</p>
<p>通常情况也越大规模的ensemble，就需要越长的session过期时间。Connetction Timeout、Read Timeout和Ping Periods都由一个以服务器数量为参数的函数计算得到，当ensemble的规模扩大，这些值需要逐渐减小。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><code>ZooKeeper</code>对象在他的生命周期内会有不同的状态，我们通过<code>getState()</code>来获取当前的状态</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>新构建的<code>ZooKeeper</code>对象在尝试连接<code>ZooKeeper</code>服务时的状态是<code>CONNECTING</code>,一旦建立成功，那么状态变成<code>CONNECTED</code><br><img data-src="/./state.jpeg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2018/03/03/%E8%81%8A%E8%81%8AGo-Channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/03/%E8%81%8A%E8%81%8AGo-Channel/" class="post-title-link" itemprop="url">聊聊Go Channel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-03 18:35:19" itemprop="dateCreated datePublished" datetime="2018-03-03T18:35:19+08:00">2018-03-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Channel</code>是<code>Go</code>的一种类型，其一种可以用来发送或者接受数据的管道。<code>Go</code>使用它来实现并发。<code>Go</code>的并发模型是<code>CSP</code>(通讯顺序进程)。<code>CSP</code>由并发执行的实体所组成，实体之间通过消息进行通讯。发送消息的通道就是<code>Channel</code>，协程就是并发执行的实体</p>
<p>&lt;!–code￼0–&gt;
</p>
<h3 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h3><p><code>Channel</code>必须使用<code>make</code>来创建指定类型的管道，可以指定管道容量,它的操作符是<code>&lt;-</code>或者<code>-&gt;</code>，箭头代表数据的流动方向，如果没有指定方向，那么其时双向</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>如果没有设置容量，那么<code>Channel</code>没有缓存,只有<code>sender</code>和<code>receiver</code>都准备好了，它们的通讯才会发生。如果设置了容量，那么会等到缓存满了<code>sender</code>才会阻塞,只有缓存空了<code>receiver</code>才会阻塞。通过<code>close</code>方法来关闭<code>Channel</code>。可以在多个协程中往一个<code>Channel</code>中发送&#x2F;接受数据而不需要考虑数据同步。<code>Channel</code>可以作为一个<code>FIFO</code>的队列。接受数据如下</p>
<p>&lt;!–code￼2–&gt;
</p>
<h3 id="发送-x2F-接受数据"><a href="#发送-x2F-接受数据" class="headerlink" title="发送&#x2F;接受数据"></a>发送&#x2F;接受数据</h3><p>&lt;!–code￼3–&gt;
</p>
<p>上述往<code>Channel c</code>中发送10，然后从c中取出。如果没有发送任何数据，那么<code>c</code>会一直<code>block</code></p>
<p>&lt;!–code￼4–&gt;
</p>
<p>上诉<code>x, y</code>会一直等到<code>sum</code>函数中的值算完并发送到<code>c</code>中</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>可以使用<code>range</code>来迭代取出<code>c</code>关闭前，所有的数据。如果<code>c</code>不被关闭,那么会一直<code>block</code>在<code>range</code>处</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>使用<code>select</code>来管理多路<code>Channel</code></p>
<p>&lt;!–code￼6–&gt;
</p>
<p>上述使用<code>c</code>作为数据体操作，使用<code>quit</code>作为数据结束操作。如果有多个<code>case</code>需要处理多个<code>Channel</code>，那么<code>go</code>会随机选择一个处理。如果没有<code>case</code>处理，那么会选择<code>default</code>处理，如果没有<code>default</code>，那么<code>select</code>会一直<code>block</code>，直到有<code>case</code>需要处理。上述代码如果把<code>quit &lt;- 0</code>注释掉，那么每5秒回打印一次<code>timeout</code></p>
<h3 id="深入chan源码"><a href="#深入chan源码" class="headerlink" title="深入chan源码"></a>深入chan源码</h3><p><code>chan</code>的源码位于<code>src/runtime/chan.go</code>中</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>chan</code>的数据结构是</p>
<p>&lt;!–code￼7–&gt;
</p>
<p><code>channel</code>由一个环形队列用于存储数据，一个写操作阻塞队列，一个读操作阻塞队列以及一个锁组成。而读写操作的列表由<code>sudog</code>实现</p>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>&lt;!–code￼8–&gt;
</p>
<p>首先进行元素类型大小限制和对齐限制。检查缓存大小，确保有足够的堆内存分配给这个<code>chan</code>。如果<code>chan</code>类型不含指针，并且大小大于0，那么分配一段内存给它。否则分配默认内存大小给它</p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>&lt;!–code￼9–&gt;
</p>
<ol>
<li><p>首先判断<code>chan</code>是否为空.如果为空，那么会使当前的<code>goroutine</code>进入休眠状态。然而<code>go</code>启动时会检测系统的运行状态。在这里其发现发数据的<code>goroutine</code>和收数据的<code>goroutine</code>都进入了休眠状态，那么系统会直接报错
<code>all goroutines are asleep - deadlock!</code></p>
</li>
<li><p><code>chan</code>非空<br>2.1 如果有读<code>goroutine</code>阻塞在<code>channel</code>上，那么直接调用<code>send</code>方法将数据发送给<code>goroutine</code><br>2.2 当前的缓存还有空间，那么将数据放到缓存里。并且调整<code>sendx</code>和<code>qcount</code>的大小<br>2.3 当前的缓存空间已满，阻塞当前的<code>goroutine</code></p>
</li>
</ol>
<p>这里数据的传递采用内存复制的方式，将写列表的数据复制到读列表数据上</p>
<h4 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h4><p>&lt;!–code￼10–&gt;
</p>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>&lt;!–code￼11–&gt;
</p>
<p>如何当前通道为空或者已经关闭，抛出异常。将读写队列的<code>goroutine</code>放到<code>glist</code>中，然后唤醒<code>glist</code>中所有的<code>goroutine</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2018/02/25/%E8%AF%B4%E8%AF%B4Go%E4%B8%AD%E7%9A%84interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/25/%E8%AF%B4%E8%AF%B4Go%E4%B8%AD%E7%9A%84interface/" class="post-title-link" itemprop="url">说说Go中的interface</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2018-02-25 17:01:30 / Modified: 17:05:51" itemprop="dateCreated datePublished" datetime="2018-02-25T17:01:30+08:00">2018-02-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>面向对象语言都会有接口这个概念。<code>go</code>中的接口就是<code>interface</code>。它跟很多别的面向对象的接口很不一样。如<code>java</code>的接口需要使用<code>implement</code>来实现接口</p>
<h3 id="interface定义"><a href="#interface定义" class="headerlink" title="interface定义"></a>interface定义</h3><p>&lt;!–code￼0–&gt;
</p>
<p>上述代码就定义了一个<code>go</code>的接口，包含了一个方法。当然也可以不包含方法。<code>go</code>的<code>interface</code>是一种具有一组方法的类型。如果一个类型实现了一个<code>interface</code>的所有方法，我们就说该类型实现了该接口。其实<code>go</code>中所有的类型都实现了<code>empty interface</code>。<code>go</code>不需要使用关键字来实现<code>interface</code>,只需要实现<code>interface</code>包含的方法即可。上述代码<code>struct S</code>实现了<code>interface I</code></p>
<h3 id="interface多态"><a href="#interface多态" class="headerlink" title="interface多态"></a>interface多态</h3><p>&lt;!–code￼1–&gt;
</p>
<p><code>interface</code>的一个重要用途就是体现在函数的参数上。函数的参数如果是<code>interface</code>，那么可以传入任意实现了该<code>interface</code>的类型。这就是多态</p>
<h3 id="判断interface类型"><a href="#判断interface类型" class="headerlink" title="判断interface类型"></a>判断<code>interface</code>类型</h3><p><code>go</code>可以使用<code>value, ok := em.(T)</code>来检查类型</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>上述代码用来检查<code>i</code>是否是<code>*S</code>类型，如果是，那么<code>ok</code>是<code>true</code>。如果需要区分多种类型那么可以使用<code>switch</code></p>
<p>&lt;!–code￼3–&gt;
</p>
<h3 id="empty-interface"><a href="#empty-interface" class="headerlink" title="empty interface"></a>empty interface</h3><p>如果定义一个函数，其参数是<code>empty interface</code>。那么这个函数可以接受任何类型作为它的参数</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>运行时<code>v</code>并不是任意类型，<code>v</code>只是一个<code>interface</code>。之所以可以接受任何类型是<code>go</code>执行时传递到函数的任何类型都被自动转换成<code>interface&#123;&#125;</code>。至于运行中是如何转换的，可以<a target="_blank" rel="noopener" href="https://research.swtch.com/interfaces">参考</a>。<code>interface&#123;&#125;</code>类型的<code>slice</code>是无法接受任何类型的</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>上述代码执行会出错，因为<code>go</code>不会为<code>interface&#123;&#125;</code>的slice做自动转换。至于为什么，可以<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/InterfaceSlice">参考</a></p>
<blockquote>
<p><code>interface&#123;&#125;</code> 会占用两个字长的存储空间，一个是自身的<code>methods</code>数据，一个是指向其存储值的指针，也就是<code>interface</code>变量存储的值，因而<code>slice[]interface&#123;&#125;</code>其长度是固定的N<em>2, 但是[]T的长度是N</em>sizeof(T)，两种 slice 实际存储值的大小是有区别的。</p>
</blockquote>
<p>虽然<code>go</code>不能帮我们自动转换，但我们可以手动转换</p>
<p>&lt;!–code￼6–&gt;
</p>
<h3 id="interface-receiver"><a href="#interface-receiver" class="headerlink" title="interface receiver"></a>interface receiver</h3><p><code>interface</code>定义时并没有严格规定实现者的方法<code>receiver</code>是个<code>value receiver</code>或者<code>pointer receiver</code>。上述代码<code>S</code>的<code>Set Receiver</code>是<code>pointer</code>，也就是实现<code>I</code>的两个方法的<code>receiver</code>一个是<code>value</code>一个是<code>pointer</code>。如果使用<code>f(s)</code>，那么传递给<code>f</code>是<code>s</code>的一个拷贝。<code>go</code>中的函数都是按值传递</p>
<p>如果是按<code>pointer</code>调用,<code>go</code>会自动进行转换，因为有了指针，那么总是能够得到指针指向的值，如果是值调用，那么无法得知原始值是什么</p>
<p>&lt;!–code￼7–&gt;
</p>
<p>上述代码<code>Pig</code>使用的是指针，如果使用值会无法运行。按值传递，函数内部对于值的任何改变都不会影响到原始值</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2018/01/01/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/01/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">SpringBoot启动流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-01 23:26:58" itemprop="dateCreated datePublished" datetime="2018-01-01T23:26:58+08:00">2018-01-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Java</code>程序的启动入口是在<code>main</code>方法。因此如果我们要了解<code>SpringBoot</code>的启动流程，那么我们可以从<code>main</code>着手</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>&lt;!–code￼0–&gt;
</p>
<h3 id="构造SpringApplication"><a href="#构造SpringApplication" class="headerlink" title="构造SpringApplication"></a>构造SpringApplication</h3><p>构造<code>SpringApplication</code>对象。在其内部进行初始化操作</p>
<p>&lt;!–code￼1–&gt;
</p>
<h4 id="判断是否是Web程序"><a href="#判断是否是Web程序" class="headerlink" title="判断是否是Web程序"></a>判断是否是Web程序</h4><p>首先将当前类添加到启动类中，判断是否是<code>Web</code>程序
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deduceWebEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">(String className, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        forName(className, classLoader);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// Class or one of its dependencies is not present...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过判断<code>javax.servlet.Servlet</code>,<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>能否被加载类确定是否是<code>Web</code>程序</p>
<h4 id="找出所有应用初始化器"><a href="#找出所有应用初始化器" class="headerlink" title="找出所有应用初始化器"></a>找出所有应用初始化器</h4><p>&lt;!–code￼3–&gt;
</p>
<p>从<code>spring.factories</code>文件中找出<code>key</code>为<code>ApplicationContextInitializer</code>的类实例并实例化，默认情况下从<code>spring.factories</code>文件中找出的<code>key</code>为<code>ApplicationContextInitializer</code>的类有以下五种:</p>
<ol>
<li>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer</li>
<li>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</li>
</ol>
<h4 id="找出所有应用程序监听器"><a href="#找出所有应用程序监听器" class="headerlink" title="找出所有应用程序监听器"></a>找出所有应用程序监听器</h4><p>从<code>spring.factories</code>中找出所有<code>key</code>为<code>ApplicationListener</code>的应用程序监听器，过程跟找出应用程序初始化器一致。</p>
<p>默认情况下，被加载的应用程序监听器有</p>
<ol>
<li>org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>org.springframework.boot.logging.LoggingApplicationListener</li>
<li>org.springframework.boot.logging.ClasspathLoggingApplicationListener</li>
<li>org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>org.springframework.boot.ClearCachesApplicationListener</li>
<li>org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<p>这些监听器在应用程序启动之后会回调执行对应的逻辑操作</p>
<h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication run"></a>SpringApplication run</h3><p>&lt;!–code￼4–&gt;
</p>
<p>首先构造<code>StopWatch</code>来统计每个任务的运行时间。</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>获取所有的应用程序监听器,然后开始监听。构建<code>DefaultApplicationArguments</code></p>
<p>&lt;!–code￼6–&gt;
</p>
<p>准备运行环境，获取或创建环境。配置属性，这个时候<code>resources</code>里的属性被读取。配置运行环境(profile)。回调监听器告知环境已经配置完成</p>
<p>&lt;!–code￼7–&gt;
</p>
<p>打印<code>Banner</code></p>
<p>&lt;!–code￼8–&gt;
</p>
<p>创建应用程序上下文</p>
<p>&lt;!–code￼9–&gt;
</p>
<p>准备上下文
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    refresh(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
刷新上下文</p>
<p>所有的这些过程都会通过<code>SpringApplicationRunListener</code>对外发送<code>SpringApplicationEvent</code>事件，这是一个订阅发布模式</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>SpringBoot</code>启动时，会加载各种初始化器，监听器，然后会通过订阅发布模式对所有的监听者发送启动过程</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2017/12/31/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/31/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2017年终总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2017-12-31 15:14:28 / Modified: 15:16:17" itemprop="dateCreated datePublished" datetime="2017-12-31T15:14:28+08:00">2017-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2017年即将过去。在此对于过去的一年做一下简单的总结</p>
<h3 id="满意的地方"><a href="#满意的地方" class="headerlink" title="满意的地方"></a>满意的地方</h3><ul>
<li>坚持写博客，坚持逛github</li>
<li>技能树更加全面的开发，接触了更多的前后端技能，朝着T字形人才的方向更进一步</li>
<li>读了很多源码</li>
<li>工作日几乎每天晚上下班之后都会继续保持学习</li>
</ul>
<h3 id="不满意的地方"><a href="#不满意的地方" class="headerlink" title="不满意的地方"></a>不满意的地方</h3><ul>
<li>github虽然一直再更新，但多数都是自己的一些实践</li>
<li>工作上，今年经历了一些不稳定，也从中收获了很多人生经验。有得有失</li>
<li>股票亏了很多</li>
<li>年初准备了考研计划，但之后的一些变动，考研计划被搁置</li>
<li>日本没有没去，希望能够早日找到自己的另一半，携手赴日</li>
</ul>
<h3 id="2018年的期待"><a href="#2018年的期待" class="headerlink" title="2018年的期待"></a>2018年的期待</h3><ul>
<li>坚持写博客，希望博客的质量能够提高</li>
<li>投入更多的精力在后端领域</li>
<li>读更多的源码</li>
<li>考研</li>
<li>股票能够好起来</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2017/12/24/MySQL-Error-Code-1215-Cannot-add-foreign-key-constraint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/24/MySQL-Error-Code-1215-Cannot-add-foreign-key-constraint/" class="post-title-link" itemprop="url">MySQL Error Code 1215: 'Cannot add foreign key constraint'</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2017-12-24 17:36:27 / Modified: 18:49:29" itemprop="dateCreated datePublished" datetime="2017-12-24T17:36:27+08:00">2017-12-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要研究一下MySql 1215的错误: “Cannot add foreign key constraint”</p>
<p>我们在设计多表关联时，经常会需要用到外键，也就是当前表引用其他表的主键。但有时候哪里写的不对，MySQL会提示1215错误。但我们并不知道是什么原因导致的错误。</p>
<p>我们来分析常见的情况:</p>
<h4 id="表或者约束引用的索引不存在-通常出现在载入存储文件"><a href="#表或者约束引用的索引不存在-通常出现在载入存储文件" class="headerlink" title="表或者约束引用的索引不存在(通常出现在载入存储文件)"></a>表或者约束引用的索引不存在(通常出现在载入存储文件)</h4><p><strong>如何诊断</strong>: 运行<code>SHOW TABLE</code>或者<code>SHOW CREATE TABLE</code>。如果出现1146错误，意味着表没有按顺序创建<br><strong>如何解决</strong>: 运行<code>CREATE TABLE</code>或者临时禁用外键</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼0–&gt;
</p>
<h4 id="表或者约束引用的索引错误引号"><a href="#表或者约束引用的索引错误引号" class="headerlink" title="表或者约束引用的索引错误引号"></a>表或者约束引用的索引错误引号</h4><p><strong>如何诊断</strong>: 检查所有的外键，确保所有的引用正确<br><strong>如何解决</strong>: 加上缺少的引号</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>这里需要注意引用表需要加上对应的列名，不能因为当前表的列名与引用表的主键名一致而忽略。</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>这里如果references后面的表明没有写上列名，会报错</p>
<h4 id="约束引用的键或表名称写错"><a href="#约束引用的键或表名称写错" class="headerlink" title="约束引用的键或表名称写错"></a>约束引用的键或表名称写错</h4><p><strong>如何诊断</strong>: 运行<code>SHOW TABLES</code>和<code>SHOW COLUMNS</code>比较声明的引用<br><strong>如何解决</strong>: 写上正确的名称</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼3–&gt;
</p>
<h4 id="约束引用的外键类型和长度不一致"><a href="#约束引用的外键类型和长度不一致" class="headerlink" title="约束引用的外键类型和长度不一致"></a>约束引用的外键类型和长度不一致</h4><p><strong>如何诊断</strong>: 运行<code>SHOW CREATE TABLE parent</code>检查所有引用类型和长度一致<br><strong>如何解决</strong>: 修改引用类型和长度</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼4–&gt;
</p>
<h4 id="外键不是KEY类型的任意一种"><a href="#外键不是KEY类型的任意一种" class="headerlink" title="外键不是KEY类型的任意一种"></a>外键不是<code>KEY</code>类型的任意一种</h4><p><strong>如何诊断</strong>: 使用<code>SHOW CREATE TABLE parent</code>来检查引用的列是正确的<br><strong>如何解决</strong>: 使引用的列加上<code>KEY,UNIQUE KEY或者PRIMARY KEY</code>的一种</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼5–&gt;
</p>
<h4 id="引用多个外键"><a href="#引用多个外键" class="headerlink" title="引用多个外键"></a>引用多个外键</h4><p><strong>如何诊断</strong>:运行<code>SHOW CREATE TABLE parent</code>检查多引用外键的正确性<br><strong>如何解决</strong>:给最左的键加上索引</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼6–&gt;
</p>
<h4 id="两个表或者列使用不同的字符集或者排序"><a href="#两个表或者列使用不同的字符集或者排序" class="headerlink" title="两个表或者列使用不同的字符集或者排序"></a>两个表或者列使用不同的字符集或者排序</h4><p><strong>如何诊断</strong>: 比较父类表和子类表的字符集和排序<br><strong>如何解决</strong>: 修改子类的字符集和排序</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼7–&gt;
</p>
<h4 id="父类表没有使用InnoDB"><a href="#父类表没有使用InnoDB" class="headerlink" title="父类表没有使用InnoDB"></a>父类表没有使用<code>InnoDB</code></h4><p><strong>如何诊断</strong>: 运行<code>SHOW CREATE TABLE parent</code>，检查是否是<code>InnoDB</code><br><strong>如何修复</strong>:修改父类表，使其采用<code>InnoDB</code></p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼8–&gt;
</p>
<h4 id="使用简短语法引用外键"><a href="#使用简短语法引用外键" class="headerlink" title="使用简短语法引用外键"></a>使用简短语法引用外键</h4><p><strong>如何诊断</strong>: 检查引用部分, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41045234/mysql-error-1215-cannot-add-foreign-key-constraint">MySQL不支持简短语法</a><br><strong>如何解决</strong>: 修改子类表，规定引用的表和列</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼9–&gt;
</p>
<h4 id="父表被分割了"><a href="#父表被分割了" class="headerlink" title="父表被分割了"></a>父表被分割了</h4><p><strong>如何诊断</strong>: 检查父表是否被分割<br><strong>如何修复</strong>: 合并被分割的部分</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼10–&gt;
</p>
<h4 id="引用的列是虚列"><a href="#引用的列是虚列" class="headerlink" title="引用的列是虚列"></a>引用的列是虚列</h4><p><strong>如何诊断</strong>: 检查引用的列是否是虚列<br><strong>如何修复</strong>: 修改父表的列，确保列不是虚列</p>
<p><strong>例子</strong>:</p>
<p>&lt;!–code￼11–&gt;
</p>
<h4 id="对约束行为使用默认集"><a href="#对约束行为使用默认集" class="headerlink" title="对约束行为使用默认集"></a>对约束行为使用默认集</h4><p><strong>如何诊断</strong>: 检查使用约束行为的字表的行为，尝试使用<code>SET DEFAULT</code><br><strong>如何修复</strong>: 移除<code>SET DEFAULT</code></p>
<p><strong>例子</strong></p>
<p>&lt;!–code￼12–&gt;
</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过以上的这些诊断基本上能够解决1215这个错误。关于外键的更多信息可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-foreign-key-constraints.html">Mysql外键约束</a></p>
<p>参考: <a target="_blank" rel="noopener" href="https://www.percona.com/blog/2017/04/06/dealing-mysql-error-code-1215-cannot-add-foreign-key-constraint/">Dealing with MySQL Error Code 1215: “Cannot add foreign key constraint”</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2017/12/17/springcloud%E4%B9%8Beureka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Binea">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/17/springcloud%E4%B9%8Beureka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">springcloud之eureka源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-17 17:06:56" itemprop="dateCreated datePublished" datetime="2017-12-17T17:06:56+08:00">2017-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Eureka是什么？"><a href="#Eureka是什么？" class="headerlink" title="Eureka是什么？"></a>Eureka是什么？</h3><blockquote>
<p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers. We call this service, the Eureka Server. Eureka also comes with a Java-based client component,the Eureka Client, which makes interactions with the service much easier. The client also has a built-in load balancer that does basic round-robin load balancing. At Netflix, a much more sophisticated load balancer wraps Eureka to provide weighted load balancing based on several factors like traffic, resource usage, error conditions etc to provide superior resiliency.</p>
</blockquote>
<p>Eureka是服务注册和发现的开源框架</p>
<h3 id="Eureka的优势"><a href="#Eureka的优势" class="headerlink" title="Eureka的优势"></a>Eureka的优势</h3><ul>
<li>提供了完整的服务注册和服务查找功能</li>
<li>SpringBoot的紧密结合</li>
</ul>
<h3 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a>Eureka架构</h3><p><img data-src="/./eureka_architecture.png" alt="eureka_architecture"></p>
<p>eureka的基本架构由三个角色组成:</p>
<ol>
<li><p>Eureka Server</p>
<ul>
<li>提供服务注册和发现</li>
</ul>
</li>
<li><p>Service Provider</p>
<ul>
<li>服务提供方</li>
<li>将自身服务注册到Eureka,从而使服务消费方能够找到</li>
</ul>
</li>
<li><p>Service Consumer</p>
<ul>
<li>服务消费方</li>
<li>从Eureka获取注册服务列表, 从而能够消费服务</li>
</ul>
</li>
</ol>
<p><img data-src="/./architecture-detail.png" alt="architecture-detail"></p>
<ul>
<li>ServiceProvider会向Eureka Server做Register(服务注册)、Renewal(服务续约)、Cancellation(服务下线)等操作</li>
<li>Eureka Server之间会做注册服务的同步，从而保证状态的同一</li>
<li>Service Consumer会向Eureka Server获取服务列表，并消费服务</li>
</ul>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>我们Application使用@EnableDiscoveryClient来进行注册，并且在application.properties中指定服务注册中心的位置</p>
<p>&lt;!–code￼0–&gt;
</p>
<p>该注解用来开启DiscoveryClient实例</p>
<p><img data-src="/./eureka_uml_01.png" alt="eureka_uml_01"></p>
<p>从上图中可以看出服务发现的结构图，左侧是netflix的框架实现部分。</p>
<h5 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h5><p>我们先找到eureka server url列表配置</p>
<p>&lt;!–code￼1–&gt;
</p>
<p>通过region获取zone，默认为default zone。根据zone获取service列表。</p>
<p>默认使用defaultZone。也可以使用eureka.client.region来配置zone</p>
<p>&lt;!–code￼2–&gt;
</p>
<p>先从指定的zone获取服务列表，如果为空，获取默认服务列表</p>
<h5 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h5><p>在DiscoveryClient的构造方法中可以找到各种初始化</p>
<p>&lt;!–code￼3–&gt;
</p>
<p>如果需要获取注册信息,使用定时器刷新注册缓存。如果要注册服务，定时器定时发送心跳来续约。创建服务信息实例，其会执行定时任务</p>
<p>&lt;!–code￼4–&gt;
</p>
<p>刷新实例信息。更新服务注册，如果注册时间过期，重新注册</p>
<p>&lt;!–code￼5–&gt;
</p>
<p>使用EurekaHttpClient注册</p>
<p>&lt;!–code￼6–&gt;
</p>
<p>使用post请求完成服务注册</p>
<h5 id="服务获取"><a href="#服务获取" class="headerlink" title="服务获取"></a>服务获取</h5><p>&lt;!–code￼7–&gt;
</p>
<h5 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h5><p>&lt;!–code￼8–&gt;
</p>
<p>发送POST心跳来续约</p>
<h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><p>&lt;!–code￼9–&gt;
</p>
<p>对注册信息进行校验,然后使用PeerAwareInstanceRegistry来进行注册</p>
<p>&lt;!–code￼10–&gt;
</p>
<p>检查租赁时间，注册指定时长的服务。同步信息到各个服务节点</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个eureka的服务注册和发现内部都是用REST方式来进行通讯以达到信息同步的目的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Binea</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
