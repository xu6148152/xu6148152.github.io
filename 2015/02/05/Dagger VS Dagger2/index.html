<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Daggerdagger是square开源的JAVA依赖注入框架，为何我们要使用依赖注入，答案在这里，简而言之依赖注入就是为某个对象提供它所需要的东西（它的依赖），而不是由依赖自己构造，这对于测试很重要。当然依赖注入不是仅仅只适用于测试，它同样也能很简单的创建可复用，高灵活性的模块。能够在整个应用程序中分享模块,也可以根据开发环境选择运行的模块。
使用Dagger声明依赖dagger会构造应用程序">
<meta property="og:type" content="article">
<meta property="og:title" content="Dagger VS Dagger2">
<meta property="og:url" content="http://xu6148152.github.io/2015/02/05/Dagger VS Dagger2/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Daggerdagger是square开源的JAVA依赖注入框架，为何我们要使用依赖注入，答案在这里，简而言之依赖注入就是为某个对象提供它所需要的东西（它的依赖），而不是由依赖自己构造，这对于测试很重要。当然依赖注入不是仅仅只适用于测试，它同样也能很简单的创建可复用，高灵活性的模块。能够在整个应用程序中分享模块,也可以根据开发环境选择运行的模块。
使用Dagger声明依赖dagger会构造应用程序">
<meta property="og:updated_time" content="2016-12-14T07:10:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dagger VS Dagger2">
<meta name="twitter:description" content="Daggerdagger是square开源的JAVA依赖注入框架，为何我们要使用依赖注入，答案在这里，简而言之依赖注入就是为某个对象提供它所需要的东西（它的依赖），而不是由依赖自己构造，这对于测试很重要。当然依赖注入不是仅仅只适用于测试，它同样也能很简单的创建可复用，高灵活性的模块。能够在整个应用程序中分享模块,也可以根据开发环境选择运行的模块。
使用Dagger声明依赖dagger会构造应用程序">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xu6148152.github.io/2015/02/05/Dagger VS Dagger2/"/>





  <title> Dagger VS Dagger2 | Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://xu6148152.github.io/2015/02/05/Dagger VS Dagger2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Binea">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/upload_file/tmp.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Dagger VS Dagger2
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-05T15:16:24+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h2><p><a href="https://github.com/square/dagger" target="_blank" rel="external">dagger</a>是square开源的JAVA<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">依赖注入</a>框架，为何我们要使用<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">依赖注入</a>，答案在<a href="http://stackoverflow.com/questions/130794/what-is-dependency-injection" target="_blank" rel="external">这里</a>，简而言之依赖注入就是为某个对象提供它所需要的东西（它的依赖），而不是由依赖自己构造，这对于测试很重要。<br>当然依赖注入不是仅仅只适用于测试，它同样也能很简单的创建可复用，高灵活性的模块。能够在整个应用程序中分享模块,也可以根据开发环境选择运行的模块。</p>
<h3 id="使用Dagger"><a href="#使用Dagger" class="headerlink" title="使用Dagger"></a>使用Dagger</h3><h5 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h5><p>dagger会构造应用程序类的实例并可以提供它所需的依赖。使用<code>javax.inject.Inject annotation</code>来定义那些构造方法和字段是应用程序需要的。</p>
<p>使用<code>@Inject</code>来注解构造方法来表示Dagger需要构造的类。当需要一个新的实例，Dagger会获取需要的参数并调用相应的构造方法。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Thermosiphon implements Pump &#123;</div><div class="line">  private final Heater heater;</div><div class="line"></div><div class="line">  @Inject</div><div class="line">  Thermosiphon(Heater heater) &#123;</div><div class="line">    this.heater = heater;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>Dagger能直接注入字段。这个例子获得一个<code>Header</code>实例和一个<code>Pump</code>实例</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class CoffeeMaker &#123;</div><div class="line">  @Inject Heater heater;</div><div class="line">  @Inject Pump pump;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>如果你的类有<code>@Inject</code>的字段，但没有<code>@Inject</code>的构造方法,Dagger将会使用无参构造方法，类如果缺少<code>@Inject</code>将无法被Dagger构造.Dagger不支持方法注入。</p>
<h3 id="满足依赖关系"><a href="#满足依赖关系" class="headerlink" title="满足依赖关系"></a>满足依赖关系</h3><p>默认情况下，Dagger通过构造实例来满足如上所述的每个依赖.如果你需要一个<code>CoffeeMaker</code>,Dagger将通过<code>new CoffeeMaker()</code>并设置可注入的字段来获取这个实例。</p>
<p>但<code>@Inject</code>并不是随处都能有效</p>
<ul>
<li>接口不能被构造  </li>
<li>第三方库的类不能被注解  </li>
<li>可配置的对象一定要配置！</li>
</ul>
<p>对于上述情况<code>@Inject</code>是无法满足的，使用<code>@Provides</code>来注解方法满足一个依赖.方法的返回值类型定义了需要的依赖。<br>例如,当需要<code>Heater</code>时，<code>provideHeater()</code>会被调用。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Provides Header provideHeader() &#123;</div><div class="line">	return new ElectricHeader();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>对于<code>@Provides</code>来获取他们自己的依赖.当需要<code>Pump</code>时，也需要一个<code>Thermosiphon</code>  </p>
<p>所有的<code>@Provides</code>方法必须属于一个模块.这些类有<code>@Module</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Module</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">	@Provides Heater provideHeater() &#123;</div><div class="line">    	return new ElectricHeater();</div><div class="line">  	&#125;</div><div class="line">  	</div><div class="line">  	@Provides Pump providePump(Thermosiphon pump) &#123;</div><div class="line">    	return pump;</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>通常,<code>@Provides</code>方法以provide为前缀，模块的类以Module为后缀</p>
<h4 id="构建视图"><a href="#构建视图" class="headerlink" title="构建视图"></a>构建视图</h4><p>含有<code>@Inject</code>和<code>@Provides</code>的类是对象的视图,被它们的依赖链接。通过<code>ObjectGraph.create()</code>来获取这个视图,这个视图可以接受一个或者多个modules:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());</div></pre></td></tr></table></figure>
</p>
<p>为了使用视图，我们需要启动注入.这通常需要注入到控制台程序的主入口类里或者是<code>android</code>中的<code>activity</code>。在<code>coffee</code>例子中，<code>CoffeeApp</code>开始依赖注入。我们要求视图提供一个被注入类的实例:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class CoffeeApp implements Runnable &#123;</div><div class="line">  @Inject CoffeeMaker coffeeMaker;</div><div class="line"></div><div class="line">  @Override public void run() &#123;</div><div class="line">    coffeeMaker.brew();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());</div><div class="line">    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>剩下的问题就是<code>CoffeeApp</code>无法被视图识别，我们需要显式的将它注册到<code>@Module</code>模块当中</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Module(</div><div class="line">    injects = CoffeeApp.class</div><div class="line">)</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>注入的选项在编译期被验证。这能够将问题前移到项目开发早期(重构)<br>既然视图已经被创建，根对象也已经注入，我们能开始运行<code>coffee maker app</code>了。</p>
<h4 id="Singletons"><a href="#Singletons" class="headerlink" title="@Singletons"></a>@Singletons</h4><p>在<code>@Provides</code>方法或者可注入的类使用<code>@Singleton</code>.视图将会使用这个类对象作为单例。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Provides @Singleton Heater provideHeater() &#123;</div><div class="line">  	return new ElectricHeater();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>在一个可注解的类使用<code>@Singleton</code>能被作为文档.它能提醒维护者知道这个类可能被多线程共享</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Singleton</div><div class="line">class CoffeeMaker &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="懒注入"><a href="#懒注入" class="headerlink" title="懒注入"></a>懒注入</h4><p>有时你会需要一个对象延后初始化。你可以延迟创建<code>Lazy&lt;T&gt;</code>直到<code>Lazy&lt;T&gt;</code>的<code>get()</code>方法被首次调用。如果T是单例，在ObjectGraph中的<code>Lazy&lt;T&gt;</code>都会是同一个实例。否则都会创建各自的<code>Lazy&lt;T&gt;</code>实例.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class GridingCoffeeMaker &#123;</div><div class="line">  @Inject Lazy&lt;Grinder&gt; lazyGrinder;</div><div class="line"></div><div class="line">  public void brew() &#123;</div><div class="line">    while (needsGrinding()) &#123;</div><div class="line">      // Grinder created once on first call to .get()		and cached.</div><div class="line">      lazyGrinder.get().grind();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="Provider的注入"><a href="#Provider的注入" class="headerlink" title="Provider的注入"></a>Provider的注入</h4><p>有时你需要获得多个实例。你有几种选择(工厂,建造者等)一种选择是注入<code>Provider&lt;T&gt;</code>而不是<code>T</code>.当<code>.get()</code>被调用时，一个<code>Provider&lt;T&gt;</code>创建一个<code>T</code>实例</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class BigCoffeeMaker &#123;</div><div class="line">  @Inject Provider&lt;Filter&gt; filterProvider;</div><div class="line"></div><div class="line">  public void brew(int numberOfPots) &#123;</div><div class="line">    ...</div><div class="line">    for (int p = 0; p &lt; numberOfPots; p++) &#123;</div><div class="line">      maker.addFilter(filterProvider.get()); //new filter every time.</div><div class="line">      maker.addCoffee(...);</div><div class="line">      maker.percolate();</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>有时单独的类型无法满足定义一个依赖。例如一个<code>sophisticated coffee maker</code> app想分离加热器的水喝托盘.<br>在这种情况下，我们添加了一个限定符注解。任何注解都有自己的一个<code>@Qualifier</code>注解</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Qualifier</div><div class="line">@Documented</div><div class="line">@Retention(RUNTIME)</div><div class="line">public @interface Named &#123;</div><div class="line">  String value() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>你能够创建你自己的限定符注解，或者直接使用<code>@Named</code>.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ExpensiveCoffeeMaker &#123;</div><div class="line">  @Inject @Named(&quot;water&quot;) Heater waterHeater;</div><div class="line">  @Inject @Named(&quot;hot plate&quot;) Heater hotPlateHeater;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Provides @Named(&quot;hot plate&quot;) Heater provideHotPlateHeater() &#123;</div><div class="line">  return new ElectricHeater(70);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Provides @Named(&quot;water&quot;) Heater provideWaterHeater() &#123;</div><div class="line">  return new ElectricHeater(93);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="静态注入-不常用"><a href="#静态注入-不常用" class="headerlink" title="静态注入(不常用)"></a>静态注入(不常用)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Module(</div><div class="line">    staticInjections = LegacyCoffeeUtils.class</div><div class="line">)</div><div class="line">class LegacyModule &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>使用<code>ObjectGraph.injectStatics()</code>来赋值这些静态字段</p>
<h4 id="编译期验证"><a href="#编译期验证" class="headerlink" title="编译期验证"></a>编译期验证</h4><p>Dagger包含了注解处理器能否验证<code>modules</code>和<code>injections</code>.这个处理器很严格，如果有任何不合理的绑定都会导致编译器错误.例如这个<code>Module</code>缺少了执行器的绑定:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Module</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">  @Provides Heater provideHeater(Executor executor) &#123;</div><div class="line">    return new CpuHeater(executor);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>可以通过为为Executor方法加上<code>@Provides</code>,或者标记这个<code>module</code>为<code>incomplete</code>.未完成的模块是可以缺少依赖。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Module(complete = false)</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">  @Provides Heater provideHeater(Executor executor) &#123;</div><div class="line">    return new CpuHeater(executor);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>模块使用被注入类中没有的类型会触发错误。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Module(injects = Example.class)</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">  @Provides Heater provideHeater() &#123;</div><div class="line">    return new ElectricHeater();</div><div class="line">  &#125;</div><div class="line">  @Provides Chiller provideChiller() &#123;</div><div class="line">    return new ElectricChiller();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>上述例子Example里仅仅只是注入了<code>Heater</code>而没有<code>Chiller</code><br>如果你的模块的绑定将会被外部使用，可以标记这个模块为<code>library</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Module(</div><div class="line">  injects = Example.class,</div><div class="line">  library = true</div><div class="line">)</div><div class="line">class DripCoffeeModule &#123;</div><div class="line">  @Provides Heater provideHeater() &#123;</div><div class="line">    return new ElectricHeater();</div><div class="line">  &#125;</div><div class="line">  @Provides Chiller provideChiller() &#123;</div><div class="line">    return new ElectricChiller();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>为了使编译期验证能够通过，创建一个模块时，可以包含所有项目中的模块。注解处理器将会检测到问题，并报告。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Module(</div><div class="line">    includes = &#123;</div><div class="line">        DripCoffeeModule.class,</div><div class="line">        ExecutorModule.class</div><div class="line">    &#125;</div><div class="line">)</div><div class="line">public class CoffeeAppModule &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="编译期代码生成"><a href="#编译期代码生成" class="headerlink" title="编译期代码生成"></a>编译期代码生成</h4><p>Dagger的注解处理器可能会生成源文件，这些源文件的名字可能像<code>$InjectAdapter.java</code>或者<code>DripCoffeeModule$ModuleAdapter</code>.这些文件是Dagger的详细实现，你不应该需要直接使用它。虽然它们能够被逐步调试。</p>
<h4 id="模块复写"><a href="#模块复写" class="headerlink" title="模块复写"></a>模块复写</h4><p>如果同样的依赖有多个竞争的<code>@Provides</code>方法,Dagger将会编译出错。但有时使用测试代码来替换产品代码是很有必要的。使用<code>@overrides = true</code>在模块注解中,能够用其他模块覆盖当前模块。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class CoffeeMakerTest &#123;</div><div class="line">  @Inject CoffeeMaker coffeeMaker;</div><div class="line">  @Inject Heater heater;</div><div class="line"></div><div class="line">  @Before public void setUp() &#123;</div><div class="line">    ObjectGraph.create(new TestModule()).inject(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Module(</div><div class="line">      includes = DripCoffeeModule.class,</div><div class="line">      injects = CoffeeMakerTest.class,</div><div class="line">      overrides = true</div><div class="line">  )</div><div class="line">  static class TestModule &#123;</div><div class="line">    @Provides @Singleton Heater provideHeater() &#123;</div><div class="line">      return Mockito.mock(Heater.class);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Test public void testHeaterIsTurnedOnAndThenOff() &#123;</div><div class="line">    Mockito.when(heater.isHot()).thenReturn(true);</div><div class="line">    coffeeMaker.brew();</div><div class="line">    Mockito.verify(heater, Mockito.times(1)).on();</div><div class="line">    Mockito.verify(heater, Mockito.times(1)).off();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h2 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h2><p>Dagger2是由Google基于Dagger的基础开发的依赖注入框架.它与Dagger有什么不同呢？主要不同在于Dagger2将Dagger中的<code>Graph</code>替换成了<code>Component</code></p>
<h4 id="构建视图-1"><a href="#构建视图-1" class="headerlink" title="构建视图"></a>构建视图</h4><p>在Dagger2中，视图是一个包含多个不带参数的方法的接口,这些方法返回相应的类型.在接口上使用<code>@Componet</code>并传入<code>module</code>类型作为模块的参数，之后Dagger2会完全生成这个接口的实现代码。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Component(modules = DripCoffeeModule.class)</div><div class="line">interface CoffeeShop &#123;</div><div class="line">  CoffeeMaker maker();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>实现有与接口一样的名字，前缀是Dagger.通过调用<code>builder()</code>获得一个实例</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CoffeeShop coffeeShop = DaggerCoffeeShop.builder()</div><div class="line">    .dripCoffeeModule(new DripCoffeeModule())</div><div class="line">    .build();</div></pre></td></tr></table></figure>
</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  static class Bar &#123;</div><div class="line">    @Component</div><div class="line">    interface BazComponent &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>上述的<code>@Component</code>将会生成一个名为<code>DaggerFoo_Bar_BazComponent</code>的组件。</p>
<p>Any module with an accessible default constructor can be elided as the builder will construct an instance automatically if none is set. And for any module whose @Provides methods are all static, the implementation doesn’t need an instance at all. If all dependencies can be constructed without the user creating a dependency instance, then the generated implementation will also have a create() method that can be used to get a new instance without having to deal with the builder.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CoffeeShop coffeeShop = DaggerCoffeeShop.create();</div></pre></td></tr></table></figure>
</p>
<p>现在<code>CoffeeApp</code>能简便的使用Dagger生成的<code>CoffeeShop</code>实现代码来拿到一个完全注入的<code>CoffeeMaker</code></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class CoffeeApp &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    CoffeeShop coffeeShop = DaggerCoffeeShop.create();</div><div class="line">    coffeeShop.maker().brew();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<h4 id="绑定视图"><a href="#绑定视图" class="headerlink" title="绑定视图"></a>绑定视图</h4><p>上述例子展示了如何构建一个带有额外类型绑定的组件,但有各种机制来绑定视图。</p>
<ul>
<li>那些直接通过<code>@Component.modules</code>或者通过<code>@Module.includes</code>引用的模块当中的方法</li>
<li>任何带有<code>@Inject</code>构造器的类型或者带有<code>@Scope</code></li>
<li>组件提供了组件依赖的方法</li>
<li>组件自己</li>
<li>任何包含子组件的建造者</li>
<li>以上绑定类型中的<code>Provider</code>或<code>Lazy</code></li>
</ul>
<h4 id="单例和作用域绑定"><a href="#单例和作用域绑定" class="headerlink" title="单例和作用域绑定"></a>单例和作用域绑定</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Provides @Singleton static Heater provideHeater() &#123;</div><div class="line">  return new ElectricHeater();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Singleton</div><div class="line">class CoffeeMaker &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>Dagger2将组件实现的实例与视图中的作用域实例联系起来了。组件需要声明他们想要对外展示的作用域。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Component(modules = DripCoffeeModule.class)</div><div class="line">@Singleton</div><div class="line">interface CoffeeShop &#123;</div><div class="line">  CoffeeMaker maker();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>
<p>Dagger支持方法注入<br>Dagger2不支持静态注入<br>Dagger2不支持Override</p>
<p>….其他的几乎都一样了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dagger1中视图是由<code>ObjectGraph</code>通过反射组成。而dagger2是由<code>@Component</code>,用户定义类型在编译期生成的。从<code>ObjectGraph</code>到<code>Component</code>的转变是Dagger1和Dagger2最大的不同。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Component(</div><div class="line">  modules = &#123;</div><div class="line">    ModuleOne.class,</div><div class="line">    ModuleTwo.class,</div><div class="line">    ModuleThree.class,</div><div class="line">  &#125;</div><div class="line">)</div><div class="line">interface MyComponent &#123;</div><div class="line">  /* Functionally equivalent to objectGraph.get(Foo.class). */</div><div class="line">  Foo getFoo();</div><div class="line">  /* Functionally equivalent to objectGraph.get(Bar.class). */</div><div class="line">  Bar getBar();</div><div class="line">  /* Functionally equivalent to objectGraph.inject(aBaz). */</div><div class="line">  Baz injectBaz(Baz baz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/01/05/SubSet/" rel="next" title="SubSet">
                <i class="fa fa-chevron-left"></i> SubSet
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/02/13/Program-principles/" rel="prev" title="编程原理">
                编程原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/upload_file/tmp.jpg"
               alt="Binea" />
          <p class="site-author-name" itemprop="name">Binea</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dagger"><span class="nav-number">1.</span> <span class="nav-text">Dagger</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Dagger"><span class="nav-number">1.1.</span> <span class="nav-text">使用Dagger</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#声明依赖"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">声明依赖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#满足依赖关系"><span class="nav-number">1.2.</span> <span class="nav-text">满足依赖关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构建视图"><span class="nav-number">1.2.1.</span> <span class="nav-text">构建视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singletons"><span class="nav-number">1.2.2.</span> <span class="nav-text">@Singletons</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#懒注入"><span class="nav-number">1.2.3.</span> <span class="nav-text">懒注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Provider的注入"><span class="nav-number">1.2.4.</span> <span class="nav-text">Provider的注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限定符"><span class="nav-number">1.2.5.</span> <span class="nav-text">限定符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态注入-不常用"><span class="nav-number">1.2.6.</span> <span class="nav-text">静态注入(不常用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译期验证"><span class="nav-number">1.2.7.</span> <span class="nav-text">编译期验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译期代码生成"><span class="nav-number">1.2.8.</span> <span class="nav-text">编译期代码生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块复写"><span class="nav-number">1.2.9.</span> <span class="nav-text">模块复写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dagger2"><span class="nav-number">2.</span> <span class="nav-text">Dagger2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构建视图-1"><span class="nav-number">2.0.1.</span> <span class="nav-text">构建视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定视图"><span class="nav-number">2.0.2.</span> <span class="nav-text">绑定视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例和作用域绑定"><span class="nav-number">2.0.3.</span> <span class="nav-text">单例和作用域绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Binea</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
